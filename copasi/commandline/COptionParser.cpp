/*
 * This file was automaticly generated by clo++ version 0.6.1 (REL-0_6_1)
 * http://pmade.org/pjones/software/clo++/
 *
 * Template enhancements by Stefan Hoops mailto:shoops@vt.edu
 */

/** @file
 * This file contains the implementation of the COptionParser class.
 * You can control the name of this source file using the
 * cxx_source_file variable.
 **/

#include "COptionParser.h"
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <fstream>
#include <sstream>

namespace
  {
  const char const_usage[] =
    "  --lib string               The location of suplementary files for copasi.\n"
    "  --rc string                The configuration file for copasi.\n"
    "  --systemFunctionDB string  A write protected database of kinetic\n"
    "                             functions.\n"
    "  --userFunctionDB string    The user extensible database of kinetic\n"
    "                             functions.\n"
    "  -s, --save string          The file the model is saved in after work.\n";

  const char const_help_comment[] =
    "use the -h option for help";

  const char* expand_long_name (const std::string &name);
}

//#########################################################################
copasi::COptionParser::COptionParser (void)
    : state_(state_option)
{
  std::memset(&locations_, 0, sizeof(locations_));
}
//#########################################################################
void copasi::COptionParser::parse(int argc, char *argv[], bool call_finalize)
{
  for (int i = 1; i < argc; ++i) parse_element(argv[i], i, source_cl);
  if (call_finalize) finalize();
}
//#########################################################################
void copasi::COptionParser::parse(const char * fileName)
{
  int LineCounter = 0;
  char Line[1027];
  char *pBegin, *pEnd, *pEqual;
  bool HaveEqual;

  std::ifstream File(fileName);
  if (File.fail())
    {
      ostringstream error;
      error << "error opening file: '" << fileName << "'";

      throw option_error(error.str());
    }

  while (true)
    {
      try
        {
          pBegin = &Line[2];
          File.getline(pBegin, 1024);
          LineCounter++;

          if (File.eof()) break;
          if (File.fail())
            {
              ostringstream error;
              error << "unknown problem";

              throw option_error(error.str());
            }

          // eat leading spaces
          while (*pBegin == ' ') pBegin++;

          // scip comments and empty lines
          if (std::strlen(pBegin) == 0 || pBegin[0] == '#') continue;

          // Remember the last character of the full line
          pEnd = pBegin + std::strlen(pBegin) - 1;

          // find position of equal sign
          for (pEqual = pBegin; *pEqual != '=' && *pEqual; pEqual++);

          HaveEqual = (pEnd >= pEqual);
          *pEqual = 0;

          // eat spaces before '='
          pEnd = pEqual - 1;
          while (pEnd > pBegin && *pEnd == ' ') *pEnd-- = 0;

          // make the string a long option
          pBegin -= 2;
          pBegin[0] = pBegin[1] = '-';
          parse_element(pBegin, LineCounter, source_cf);

          if (HaveEqual) // We have a '='
            {
              // eat spaces after '='
              pBegin = pEqual + 1;
              while (*pBegin == ' ') pBegin++;

              // eat trailing spaces
              pEnd = pBegin + std::strlen(pBegin) - 1;
              while (pEnd > pBegin && *pEnd == ' ') *pEnd-- = 0;

              if (pBegin < pEnd) parse_element(pBegin, LineCounter, source_cf);
            }

          finalize();
        }

      catch (copasi::option_error &e)
        {
          ostringstream error;
          error << "error reading file: '" << fileName << "(" << LineCounter
          << ")': " << e.what();

          throw option_error(error.str());
        }
    }

  File.clear();
  File.close();
}
//#########################################################################
void copasi::COptionParser::finalize (void)
{
  if (state_ == state_value)
    {
      switch (openum_)
        {
        case option_CopasiLib:
          throw option_error("missing value for 'lib' option");
        case option_SystemFunctionDB:
          throw option_error("missing value for 'systemFunctionDB' option");
        case option_UserFunctionDB:
          throw option_error("missing value for 'userFunctionDB' option");
        case option_rc:
          throw option_error("missing value for 'rc' option");
        case option_save:
          throw option_error("missing value for 'save' option");
        }
    }
}
//#########################################################################
void copasi::COptionParser::parse_element (const char *element, int position, opsource source)
{
  std::size_t length = std::strlen(element);

  switch (state_)
    {
    case state_consume:
      non_options_.push_back(element);
      break;
    case state_option:
      if (length >= 2 && element[0] == '-' && element[1] == '-')
        {
          if (length == 2) {state_ = state_consume; return;}
          element += 2;
          const char *value = element;
          while (*value != 0 && *value != '=') ++value;
          if (*value == '=')
            {
              std::string selement(element, value - element), svalue(++value);

              parse_long_option(selement.c_str(), position, source);
              if (state_ != state_value)
                {
                  std::string error("the '"); error += element; error += "' option does not take a value";
                  throw option_error(error);
                }

              parse_value(svalue.c_str());
              state_ = state_option;
            }
          else
            {
              parse_long_option(element, position, source);
            }
        }
      else if (length >= 2 && element[0] == '-')
        {
          ++element;

          if (length > 2)
            {
              while (*element != 0)
                {
                  parse_short_option(*element, position, source);
                  ++element;

                  if (state_ == state_value && *element == '=')
                    {
                      parse_value(++element);
                      state_ = state_option;
                      break;
                    }
                  else if (state_ == state_value) finalize();
                }
            }
          else
            {
              parse_short_option(*element, position, source);
            }
        }
      else
        {
          non_options_.push_back(element);
        }
      break;
    case state_value:
      parse_value(element);
      state_ = state_option;
      break;
    }
}
//#########################################################################
void copasi::COptionParser::parse_short_option (char option, int position, opsource source)
{
  switch (option)
    {
    case 's':
      if (locations_.save)
        {
          throw option_error("the 'save' option is only allowed once");
        }
      openum_ = option_save;
      state_ = state_value;
      if (source == source_cl) locations_.save = position;
      return;
    case 'h':
      if (source != source_cl) break;
      throw autoexcept(autothrow_help, const_usage);
    case '?':
      if (source != source_cl) break;
      throw autoexcept(autothrow_help, const_usage);
    }

  std::string error("unknown option: '"); error += option; error += "'";
  throw option_error(error);
}
//#########################################################################
void copasi::COptionParser::parse_long_option (const char *option, int position, opsource source)
{
  option = expand_long_name(option);

  if (std::strcmp(option, "lib") == 0)
    {
      if (locations_.CopasiLib)
        {
          throw option_error("the 'lib' option is only allowed once");
        }
      openum_ = option_CopasiLib;
      if (source == source_cl) locations_.CopasiLib = position;
      state_ = state_value;
      return;
    }
  else if (source == source_cl && std::strcmp(option, "rc") == 0)
    {
      if (locations_.rc)
        {
          throw option_error("the 'rc' option is only allowed once");
        }
      openum_ = option_rc;
      if (source == source_cl) locations_.rc = position;
      state_ = state_value;
      return;
    }
  else if (std::strcmp(option, "save") == 0)
    {
      if (locations_.save)
        {
          throw option_error("the 'save' option is only allowed once");
        }
      openum_ = option_save;
      if (source == source_cl) locations_.save = position;
      state_ = state_value;
      return;
    }
  else if (std::strcmp(option, "systemFunctionDB") == 0)
    {
      if (locations_.SystemFunctionDB)
        {
          throw option_error("the 'systemFunctionDB' option is only allowed once");
        }
      openum_ = option_SystemFunctionDB;
      if (source == source_cl) locations_.SystemFunctionDB = position;
      state_ = state_value;
      return;
    }
  else if (std::strcmp(option, "userFunctionDB") == 0)
    {
      if (locations_.UserFunctionDB)
        {
          throw option_error("the 'userFunctionDB' option is only allowed once");
        }
      openum_ = option_UserFunctionDB;
      if (source == source_cl) locations_.UserFunctionDB = position;
      state_ = state_value;
      return;
    }
  else if (source == source_cl && std::strcmp(option, "help") == 0)
    {
      throw autoexcept(autothrow_help, const_usage);
    }

  std::string error("unknown option '"); error += option; error += "'";
  throw option_error(error);
}
//#########################################################################
void copasi::COptionParser::parse_value (const char *value)
{
  switch (openum_)
    {
    case option_CopasiLib:
      {
        options_.CopasiLib = value;
      }
      break;
    case option_SystemFunctionDB:
      {
        options_.SystemFunctionDB = value;
      }
      break;
    case option_UserFunctionDB:
      {
        options_.UserFunctionDB = value;
      }
      break;
    case option_rc:
      {
        options_.rc = value;
      }
      break;
    case option_save:
      {
        options_.save = value;
      }
      break;
    }
}
//#########################################################################
const char* copasi::option_error::get_help_comment (void) const {
  return const_help_comment;
}
//#########################################################################
namespace
  {
  const char* expand_long_name (const std::string &name)
  {
    std::string::size_type name_size = name.size();
    std::vector<const char*> matches;

    if (name_size <= 3 && name.compare("lib") == 0)
      matches.push_back("lib");

    if (name_size <= 2 && name.compare("rc") == 0)
      matches.push_back("rc");

    if (name_size <= 4 && name.compare("save") == 0)
      matches.push_back("save");

    if (name_size <= 16 && name.compare("systemFunctionDB") == 0)
      matches.push_back("systemFunctionDB");

    if (name_size <= 14 && name.compare("userFunctionDB") == 0)
      matches.push_back("userFunctionDB");

    if (name_size <= 4 && name.compare("help") == 0)
      matches.push_back("help");

    if (matches.empty())
      {
        std::string error("unknown option '"); error += name; error += "'";
        throw copasi::option_error(error);
      }

    if (matches.size() == 1)
      {
        return matches[0];
      }

    std::string error("the option name '"); error += name; error += "' is ambiguous";
    throw copasi::option_error(error);
  }
} // end anonymous namespace
