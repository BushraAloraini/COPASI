// The bison parser together with CEvaluationFlexLexer builds
// the evaluation tree.

%{
#define YYSTYPE CUnitParserBase::Data

#ifdef yylval
# undef yylval
#endif
#define yylval mData

#ifdef yyerror
# undef yyerror
#endif
#define yyerror(__str) \
  if (yychar != YYERRCODE) correctErrorPosition(); \
  CCopasiMessage(CCopasiMessage::ERROR, MCFunction + 1, mPosition)

#include "copasi.h"
#include "CUnitParser.h"

#include "utilities/CCopasiMessage.h"
#include "utilities/utility.h"

#undef yyparse
#define yyparse CUnitParserBase::yyparse
%}

/* yacc Declarations */
%token SCALE
%token KIND
%token NUMBER
%token MULTIPLY
%token DIVIDE
%token START_PARENS
%token END_PARENS
%token EXPONENT

// Precedence
%left SCALE
%left KIND
%left NUMBER
%left MULTIPLY
%left DIVIDE
%left START_PARENS
%left END_PARENS
%right EXPONENT

/* Grammar follows */
%%

list_of_components:  component
           {
             $$.unit.addComponent($$.component);
           }
         | list_of_components MULTIPLY list_of_components
           {
             $$.unit = $1.unit * $2.unit;
           }
         | list_of_components DIVIDE list_of_components
           {
             $$.unit = $1.unit * $2.unit.exponentiate(-1);
           }
         | START_PARENS list_of_components END_PARENS
           {
             $$ = $2;
           }
         | list_of_components EXPONENT NUMBER
           {
             $$.unit = $1.unit.exponentiate(strToDouble($3.text.c_str(), NULL));
           }

component: scaled_kind
         | NUMBER scaled_kind
           {
             $$ = $2;
             $$.component.setMultiplier(strToDouble($1.text.c_str(), NULL));
           }

scaled_kind: KIND
           {
             $$.component.setKind(CBaseUnit::fromSymbol($1.text));
           }
         | SCALE KIND
           {
             $$.component.setScale(CBaseUnit::scaleFromPrefix($1.text));
             $$.component.setKind(CBaseUnit::fromSymbol($2.text));
           }
;

%%

