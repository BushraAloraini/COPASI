// Begin CVS Header
//   $Source: /Volumes/Home/Users/shoops/cvs/copasi_dev/copasi/MIRIAM/WebServicesIssues/soapC.cpp,v $
//   $Revision: 1.3 $
//   $Name:  $
//   $Author: aruff $
//   $Date: 2008/09/17 17:41:51 $
// End CVS Header

// Copyright (C) 2008 by Pedro Mendes, Virginia Tech Intellectual
// Properties, Inc., EML Research, gGmbH, University of Heidelberg,
// and The University of Manchester.
// All rights reserved.

/* soapC.cpp
   Generated by gSOAP 2.7.11 from miriam.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
 */

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.11 2008-08-08 20:25:58 GMT")

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
  if (soap->header)
    soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
  if (soap->header)
    {
      soap->part = SOAP_IN_HEADER;
      if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
        return soap->error;
      soap->part = SOAP_END_HEADER;
    }
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
  soap->part = SOAP_IN_HEADER;
  soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
  soap->part = SOAP_END_HEADER;
  return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
  if (!soap->header)
    {
      soap->header = soap_new_SOAP_ENV__Header(soap, -1);
      soap_default_SOAP_ENV__Header(soap, soap->header);
    }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
  if (!soap->fault)
    {
      soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
      if (!soap->fault)
        return;
      soap_default_SOAP_ENV__Fault(soap, soap->fault);
    }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
    {
      soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
      soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
    }
  if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
    {
      soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
      soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
    }
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
  soap_fault(soap);
  if (soap->fault)
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
  if (soap->fault)
    return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
  return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
  return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
  soap_fault(soap);
  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
  soap_fault(soap);
  if (soap->version == 2)
    {
      if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
        {
          soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
          soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
        }
      return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
    }
  return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
  soap_fault(soap);
  if (soap->version == 2)
    return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
  return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
  soap_fault(soap);
  if (soap->version == 1)
    {
      if (!soap->fault->detail)
        {
          soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
          soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
        }
      return (const char**)&soap->fault->detail->__any;
    }
  if (!soap->fault->SOAP_ENV__Detail)
    {
      soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
      soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
    }
  return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
  int t;
  for (;;)
    if (!soap_getelement(soap, &t))
      if (soap->error || soap_ignore_element(soap))
        break;
  if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
    soap->error = SOAP_OK;
  return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C"
  {
#endif
    SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
    {
      if (soap_peek_element(soap))
        return NULL;
      if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
        *type = soap_lookup_type(soap, soap->href);
      switch (*type)
        {
        case SOAP_TYPE_byte:
          return soap_in_byte(soap, NULL, NULL, "xsd:byte");
        case SOAP_TYPE_int:
          return soap_in_int(soap, NULL, NULL, "xsd:int");
        case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
          return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_ns2__checkRegExp:
          return soap_in_ns2__checkRegExp(soap, NULL, NULL, "ns2:checkRegExp");
        case SOAP_TYPE_ns2__checkRegExpResponse:
          return soap_in_ns2__checkRegExpResponse(soap, NULL, NULL, "ns2:checkRegExpResponse");
        case SOAP_TYPE_ns2__getDataTypesId:
          return soap_in_ns2__getDataTypesId(soap, NULL, NULL, "ns2:getDataTypesId");
        case SOAP_TYPE_ns2__getDataTypesIdResponse:
          return soap_in_ns2__getDataTypesIdResponse(soap, NULL, NULL, "ns2:getDataTypesIdResponse");
        case SOAP_TYPE_ns2__getDataTypesName:
          return soap_in_ns2__getDataTypesName(soap, NULL, NULL, "ns2:getDataTypesName");
        case SOAP_TYPE_ns2__getDataTypesNameResponse:
          return soap_in_ns2__getDataTypesNameResponse(soap, NULL, NULL, "ns2:getDataTypesNameResponse");
        case SOAP_TYPE_ns2__getNames:
          return soap_in_ns2__getNames(soap, NULL, NULL, "ns2:getNames");
        case SOAP_TYPE_ns2__getNamesResponse:
          return soap_in_ns2__getNamesResponse(soap, NULL, NULL, "ns2:getNamesResponse");
        case SOAP_TYPE_ns2__getDataTypeSynonyms:
          return soap_in_ns2__getDataTypeSynonyms(soap, NULL, NULL, "ns2:getDataTypeSynonyms");
        case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
          return soap_in_ns2__getDataTypeSynonymsResponse(soap, NULL, NULL, "ns2:getDataTypeSynonymsResponse");
        case SOAP_TYPE_ns2__getResourceLocation:
          return soap_in_ns2__getResourceLocation(soap, NULL, NULL, "ns2:getResourceLocation");
        case SOAP_TYPE_ns2__getResourceLocationResponse:
          return soap_in_ns2__getResourceLocationResponse(soap, NULL, NULL, "ns2:getResourceLocationResponse");
        case SOAP_TYPE_ns2__getResourceInstitution:
          return soap_in_ns2__getResourceInstitution(soap, NULL, NULL, "ns2:getResourceInstitution");
        case SOAP_TYPE_ns2__getResourceInstitutionResponse:
          return soap_in_ns2__getResourceInstitutionResponse(soap, NULL, NULL, "ns2:getResourceInstitutionResponse");
        case SOAP_TYPE_ns2__getResourceInfo:
          return soap_in_ns2__getResourceInfo(soap, NULL, NULL, "ns2:getResourceInfo");
        case SOAP_TYPE_ns2__getResourceInfoResponse:
          return soap_in_ns2__getResourceInfoResponse(soap, NULL, NULL, "ns2:getResourceInfoResponse");
        case SOAP_TYPE_ns2__getDataTypePattern:
          return soap_in_ns2__getDataTypePattern(soap, NULL, NULL, "ns2:getDataTypePattern");
        case SOAP_TYPE_ns2__getDataTypePatternResponse:
          return soap_in_ns2__getDataTypePatternResponse(soap, NULL, NULL, "ns2:getDataTypePatternResponse");
        case SOAP_TYPE_ns2__getMiriamURI:
          return soap_in_ns2__getMiriamURI(soap, NULL, NULL, "ns2:getMiriamURI");
        case SOAP_TYPE_ns2__getMiriamURIResponse:
          return soap_in_ns2__getMiriamURIResponse(soap, NULL, NULL, "ns2:getMiriamURIResponse");
        case SOAP_TYPE_ns2__getOfficialDataTypeURI:
          return soap_in_ns2__getOfficialDataTypeURI(soap, NULL, NULL, "ns2:getOfficialDataTypeURI");
        case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
          return soap_in_ns2__getOfficialDataTypeURIResponse(soap, NULL, NULL, "ns2:getOfficialDataTypeURIResponse");
        case SOAP_TYPE_ns2__getOfficialURI:
          return soap_in_ns2__getOfficialURI(soap, NULL, NULL, "ns2:getOfficialURI");
        case SOAP_TYPE_ns2__getOfficialURIResponse:
          return soap_in_ns2__getOfficialURIResponse(soap, NULL, NULL, "ns2:getOfficialURIResponse");
        case SOAP_TYPE_ns2__isDeprecated:
          return soap_in_ns2__isDeprecated(soap, NULL, NULL, "ns2:isDeprecated");
        case SOAP_TYPE_ns2__isDeprecatedResponse:
          return soap_in_ns2__isDeprecatedResponse(soap, NULL, NULL, "ns2:isDeprecatedResponse");
        case SOAP_TYPE_ns2__getDataResources:
          return soap_in_ns2__getDataResources(soap, NULL, NULL, "ns2:getDataResources");
        case SOAP_TYPE_ns2__getDataResourcesResponse:
          return soap_in_ns2__getDataResourcesResponse(soap, NULL, NULL, "ns2:getDataResourcesResponse");
        case SOAP_TYPE_ns2__getDataEntry:
          return soap_in_ns2__getDataEntry(soap, NULL, NULL, "ns2:getDataEntry");
        case SOAP_TYPE_ns2__getDataEntryResponse:
          return soap_in_ns2__getDataEntryResponse(soap, NULL, NULL, "ns2:getDataEntryResponse");
        case SOAP_TYPE_ns2__getLocations_:
          return soap_in_ns2__getLocations_(soap, NULL, NULL, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse_:
          return soap_in_ns2__getLocationsResponse_(soap, NULL, NULL, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getLocations:
          return soap_in_ns2__getLocations(soap, NULL, NULL, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse:
          return soap_in_ns2__getLocationsResponse(soap, NULL, NULL, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getDataEntries_:
          return soap_in_ns2__getDataEntries_(soap, NULL, NULL, "ns2:getDataEntries");
        case SOAP_TYPE_ns2__getDataEntriesResponse_:
          return soap_in_ns2__getDataEntriesResponse_(soap, NULL, NULL, "ns2:getDataEntriesResponse");
        case SOAP_TYPE_ns2__getDataEntries:
          return soap_in_ns2__getDataEntries(soap, NULL, NULL, "ns2:getDataEntries");
        case SOAP_TYPE_ns2__getDataEntriesResponse:
          return soap_in_ns2__getDataEntriesResponse(soap, NULL, NULL, "ns2:getDataEntriesResponse");
        case SOAP_TYPE_ns2__getDataTypeDef:
          return soap_in_ns2__getDataTypeDef(soap, NULL, NULL, "ns2:getDataTypeDef");
        case SOAP_TYPE_ns2__getDataTypeDefResponse:
          return soap_in_ns2__getDataTypeDefResponse(soap, NULL, NULL, "ns2:getDataTypeDefResponse");
        case SOAP_TYPE_ns2__getURN:
          return soap_in_ns2__getURN(soap, NULL, NULL, "ns2:getURN");
        case SOAP_TYPE_ns2__getURNResponse:
          return soap_in_ns2__getURNResponse(soap, NULL, NULL, "ns2:getURNResponse");
        case SOAP_TYPE_ns2__getDataTypeAllURIs:
          return soap_in_ns2__getDataTypeAllURIs(soap, NULL, NULL, "ns2:getDataTypeAllURIs");
        case SOAP_TYPE_ns2__getDataTypeAllURIsResponse:
          return soap_in_ns2__getDataTypeAllURIsResponse(soap, NULL, NULL, "ns2:getDataTypeAllURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURIs_:
          return soap_in_ns2__getDataTypeURIs_(soap, NULL, NULL, "ns2:getDataTypeURIs");
        case SOAP_TYPE_ns2__getDataTypeURIsResponse_:
          return soap_in_ns2__getDataTypeURIsResponse_(soap, NULL, NULL, "ns2:getDataTypeURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURIs:
          return soap_in_ns2__getDataTypeURIs(soap, NULL, NULL, "ns2:getDataTypeURIs");
        case SOAP_TYPE_ns2__getDataTypeURIsResponse:
          return soap_in_ns2__getDataTypeURIsResponse(soap, NULL, NULL, "ns2:getDataTypeURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURI_:
          return soap_in_ns2__getDataTypeURI_(soap, NULL, NULL, "ns2:getDataTypeURI");
        case SOAP_TYPE_ns2__getDataTypeURI_Response:
          return soap_in_ns2__getDataTypeURI_Response(soap, NULL, NULL, "ns2:getDataTypeURI-Response");
        case SOAP_TYPE_ns2__getDataTypeURI:
          return soap_in_ns2__getDataTypeURI(soap, NULL, NULL, "ns2:getDataTypeURI");
        case SOAP_TYPE_ns2__getDataTypeURIResponse:
          return soap_in_ns2__getDataTypeURIResponse(soap, NULL, NULL, "ns2:getDataTypeURIResponse");
        case SOAP_TYPE_ns2__getDataTypeURLs:
          return soap_in_ns2__getDataTypeURLs(soap, NULL, NULL, "ns2:getDataTypeURLs");
        case SOAP_TYPE_ns2__getDataTypeURLsResponse:
          return soap_in_ns2__getDataTypeURLsResponse(soap, NULL, NULL, "ns2:getDataTypeURLsResponse");
        case SOAP_TYPE_ns2__getDataTypeURL:
          return soap_in_ns2__getDataTypeURL(soap, NULL, NULL, "ns2:getDataTypeURL");
        case SOAP_TYPE_ns2__getDataTypeURLResponse:
          return soap_in_ns2__getDataTypeURLResponse(soap, NULL, NULL, "ns2:getDataTypeURLResponse");
        case SOAP_TYPE_ns2__getDataTypeURNs:
          return soap_in_ns2__getDataTypeURNs(soap, NULL, NULL, "ns2:getDataTypeURNs");
        case SOAP_TYPE_ns2__getDataTypeURNsResponse:
          return soap_in_ns2__getDataTypeURNsResponse(soap, NULL, NULL, "ns2:getDataTypeURNsResponse");
        case SOAP_TYPE_ns2__getDataTypeURN:
          return soap_in_ns2__getDataTypeURN(soap, NULL, NULL, "ns2:getDataTypeURN");
        case SOAP_TYPE_ns2__getDataTypeURNResponse:
          return soap_in_ns2__getDataTypeURNResponse(soap, NULL, NULL, "ns2:getDataTypeURNResponse");
        case SOAP_TYPE_ns2__getJavaLibraryVersion:
          return soap_in_ns2__getJavaLibraryVersion(soap, NULL, NULL, "ns2:getJavaLibraryVersion");
        case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
          return soap_in_ns2__getJavaLibraryVersionResponse(soap, NULL, NULL, "ns2:getJavaLibraryVersionResponse");
        case SOAP_TYPE_ns2__getServicesVersion:
          return soap_in_ns2__getServicesVersion(soap, NULL, NULL, "ns2:getServicesVersion");
        case SOAP_TYPE_ns2__getServicesVersionResponse:
          return soap_in_ns2__getServicesVersionResponse(soap, NULL, NULL, "ns2:getServicesVersionResponse");
        case SOAP_TYPE_ns2__getServicesInfo:
          return soap_in_ns2__getServicesInfo(soap, NULL, NULL, "ns2:getServicesInfo");
        case SOAP_TYPE_ns2__getServicesInfoResponse:
          return soap_in_ns2__getServicesInfoResponse(soap, NULL, NULL, "ns2:getServicesInfoResponse");
        case SOAP_TYPE_ns2__getURI_:
          return soap_in_ns2__getURI_(soap, NULL, NULL, "ns2:getURI");
        case SOAP_TYPE_ns2__getURI_Response:
          return soap_in_ns2__getURI_Response(soap, NULL, NULL, "ns2:getURI-Response");
        case SOAP_TYPE_ns2__getURI:
          return soap_in_ns2__getURI(soap, NULL, NULL, "ns2:getURI");
        case SOAP_TYPE_ns2__getURIResponse:
          return soap_in_ns2__getURIResponse(soap, NULL, NULL, "ns2:getURIResponse");
        case SOAP_TYPE_ns2__getURL:
          return soap_in_ns2__getURL(soap, NULL, NULL, "ns2:getURL");
        case SOAP_TYPE_ns2__getURLResponse:
          return soap_in_ns2__getURLResponse(soap, NULL, NULL, "ns2:getURLResponse");
        case SOAP_TYPE_ns2__getLocation:
          return soap_in_ns2__getLocation(soap, NULL, NULL, "ns2:getLocation");
        case SOAP_TYPE_ns2__getLocationResponse:
          return soap_in_ns2__getLocationResponse(soap, NULL, NULL, "ns2:getLocationResponse");
        case SOAP_TYPE_ns2__getName:
          return soap_in_ns2__getName(soap, NULL, NULL, "ns2:getName");
        case SOAP_TYPE_ns2__getNameResponse:
          return soap_in_ns2__getNameResponse(soap, NULL, NULL, "ns2:getNameResponse");
        case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
          return soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_PointerTostring:
          return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
        case SOAP_TYPE_string:
          {
            char **s;
            s = soap_in_string(soap, NULL, NULL, "xsd:string");
            return s ? *s : NULL;
          }
        default:
          {
            const char *t = soap->type;
            if (!*t)
              t = soap->tag;
            if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
              {
                *type = SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring;
                return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "xsd:byte"))
              {
                *type = SOAP_TYPE_byte;
                return soap_in_byte(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "xsd:int"))
              {
                *type = SOAP_TYPE_int;
                return soap_in_int(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:checkRegExp"))
              {
                *type = SOAP_TYPE_ns2__checkRegExp;
                return soap_in_ns2__checkRegExp(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:checkRegExpResponse"))
              {
                *type = SOAP_TYPE_ns2__checkRegExpResponse;
                return soap_in_ns2__checkRegExpResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypesId"))
              {
                *type = SOAP_TYPE_ns2__getDataTypesId;
                return soap_in_ns2__getDataTypesId(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypesIdResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypesIdResponse;
                return soap_in_ns2__getDataTypesIdResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypesName"))
              {
                *type = SOAP_TYPE_ns2__getDataTypesName;
                return soap_in_ns2__getDataTypesName(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypesNameResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypesNameResponse;
                return soap_in_ns2__getDataTypesNameResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getNames"))
              {
                *type = SOAP_TYPE_ns2__getNames;
                return soap_in_ns2__getNames(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getNamesResponse"))
              {
                *type = SOAP_TYPE_ns2__getNamesResponse;
                return soap_in_ns2__getNamesResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeSynonyms"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeSynonyms;
                return soap_in_ns2__getDataTypeSynonyms(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeSynonymsResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeSynonymsResponse;
                return soap_in_ns2__getDataTypeSynonymsResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getResourceLocation"))
              {
                *type = SOAP_TYPE_ns2__getResourceLocation;
                return soap_in_ns2__getResourceLocation(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getResourceLocationResponse"))
              {
                *type = SOAP_TYPE_ns2__getResourceLocationResponse;
                return soap_in_ns2__getResourceLocationResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getResourceInstitution"))
              {
                *type = SOAP_TYPE_ns2__getResourceInstitution;
                return soap_in_ns2__getResourceInstitution(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getResourceInstitutionResponse"))
              {
                *type = SOAP_TYPE_ns2__getResourceInstitutionResponse;
                return soap_in_ns2__getResourceInstitutionResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getResourceInfo"))
              {
                *type = SOAP_TYPE_ns2__getResourceInfo;
                return soap_in_ns2__getResourceInfo(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getResourceInfoResponse"))
              {
                *type = SOAP_TYPE_ns2__getResourceInfoResponse;
                return soap_in_ns2__getResourceInfoResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypePattern"))
              {
                *type = SOAP_TYPE_ns2__getDataTypePattern;
                return soap_in_ns2__getDataTypePattern(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypePatternResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypePatternResponse;
                return soap_in_ns2__getDataTypePatternResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getMiriamURI"))
              {
                *type = SOAP_TYPE_ns2__getMiriamURI;
                return soap_in_ns2__getMiriamURI(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getMiriamURIResponse"))
              {
                *type = SOAP_TYPE_ns2__getMiriamURIResponse;
                return soap_in_ns2__getMiriamURIResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getOfficialDataTypeURI"))
              {
                *type = SOAP_TYPE_ns2__getOfficialDataTypeURI;
                return soap_in_ns2__getOfficialDataTypeURI(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getOfficialDataTypeURIResponse"))
              {
                *type = SOAP_TYPE_ns2__getOfficialDataTypeURIResponse;
                return soap_in_ns2__getOfficialDataTypeURIResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getOfficialURI"))
              {
                *type = SOAP_TYPE_ns2__getOfficialURI;
                return soap_in_ns2__getOfficialURI(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getOfficialURIResponse"))
              {
                *type = SOAP_TYPE_ns2__getOfficialURIResponse;
                return soap_in_ns2__getOfficialURIResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:isDeprecated"))
              {
                *type = SOAP_TYPE_ns2__isDeprecated;
                return soap_in_ns2__isDeprecated(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:isDeprecatedResponse"))
              {
                *type = SOAP_TYPE_ns2__isDeprecatedResponse;
                return soap_in_ns2__isDeprecatedResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataResources"))
              {
                *type = SOAP_TYPE_ns2__getDataResources;
                return soap_in_ns2__getDataResources(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataResourcesResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataResourcesResponse;
                return soap_in_ns2__getDataResourcesResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataEntry"))
              {
                *type = SOAP_TYPE_ns2__getDataEntry;
                return soap_in_ns2__getDataEntry(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataEntryResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataEntryResponse;
                return soap_in_ns2__getDataEntryResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getLocations"))
              {
                *type = SOAP_TYPE_ns2__getLocations_;
                return soap_in_ns2__getLocations_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getLocationsResponse"))
              {
                *type = SOAP_TYPE_ns2__getLocationsResponse_;
                return soap_in_ns2__getLocationsResponse_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getLocations"))
              {
                *type = SOAP_TYPE_ns2__getLocations;
                return soap_in_ns2__getLocations(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getLocationsResponse"))
              {
                *type = SOAP_TYPE_ns2__getLocationsResponse;
                return soap_in_ns2__getLocationsResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataEntries"))
              {
                *type = SOAP_TYPE_ns2__getDataEntries_;
                return soap_in_ns2__getDataEntries_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataEntriesResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataEntriesResponse_;
                return soap_in_ns2__getDataEntriesResponse_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataEntries"))
              {
                *type = SOAP_TYPE_ns2__getDataEntries;
                return soap_in_ns2__getDataEntries(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataEntriesResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataEntriesResponse;
                return soap_in_ns2__getDataEntriesResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeDef"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeDef;
                return soap_in_ns2__getDataTypeDef(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeDefResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeDefResponse;
                return soap_in_ns2__getDataTypeDefResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURN"))
              {
                *type = SOAP_TYPE_ns2__getURN;
                return soap_in_ns2__getURN(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURNResponse"))
              {
                *type = SOAP_TYPE_ns2__getURNResponse;
                return soap_in_ns2__getURNResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeAllURIs"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeAllURIs;
                return soap_in_ns2__getDataTypeAllURIs(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeAllURIsResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeAllURIsResponse;
                return soap_in_ns2__getDataTypeAllURIsResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURIs"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURIs_;
                return soap_in_ns2__getDataTypeURIs_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURIsResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURIsResponse_;
                return soap_in_ns2__getDataTypeURIsResponse_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURIs"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURIs;
                return soap_in_ns2__getDataTypeURIs(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURIsResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURIsResponse;
                return soap_in_ns2__getDataTypeURIsResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURI"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURI_;
                return soap_in_ns2__getDataTypeURI_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURI-Response"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURI_Response;
                return soap_in_ns2__getDataTypeURI_Response(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURI"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURI;
                return soap_in_ns2__getDataTypeURI(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURIResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURIResponse;
                return soap_in_ns2__getDataTypeURIResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURLs"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURLs;
                return soap_in_ns2__getDataTypeURLs(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURLsResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURLsResponse;
                return soap_in_ns2__getDataTypeURLsResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURL"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURL;
                return soap_in_ns2__getDataTypeURL(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURLResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURLResponse;
                return soap_in_ns2__getDataTypeURLResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURNs"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURNs;
                return soap_in_ns2__getDataTypeURNs(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURNsResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURNsResponse;
                return soap_in_ns2__getDataTypeURNsResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURN"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURN;
                return soap_in_ns2__getDataTypeURN(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getDataTypeURNResponse"))
              {
                *type = SOAP_TYPE_ns2__getDataTypeURNResponse;
                return soap_in_ns2__getDataTypeURNResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getJavaLibraryVersion"))
              {
                *type = SOAP_TYPE_ns2__getJavaLibraryVersion;
                return soap_in_ns2__getJavaLibraryVersion(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getJavaLibraryVersionResponse"))
              {
                *type = SOAP_TYPE_ns2__getJavaLibraryVersionResponse;
                return soap_in_ns2__getJavaLibraryVersionResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getServicesVersion"))
              {
                *type = SOAP_TYPE_ns2__getServicesVersion;
                return soap_in_ns2__getServicesVersion(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getServicesVersionResponse"))
              {
                *type = SOAP_TYPE_ns2__getServicesVersionResponse;
                return soap_in_ns2__getServicesVersionResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getServicesInfo"))
              {
                *type = SOAP_TYPE_ns2__getServicesInfo;
                return soap_in_ns2__getServicesInfo(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getServicesInfoResponse"))
              {
                *type = SOAP_TYPE_ns2__getServicesInfoResponse;
                return soap_in_ns2__getServicesInfoResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURI"))
              {
                *type = SOAP_TYPE_ns2__getURI_;
                return soap_in_ns2__getURI_(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURI-Response"))
              {
                *type = SOAP_TYPE_ns2__getURI_Response;
                return soap_in_ns2__getURI_Response(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURI"))
              {
                *type = SOAP_TYPE_ns2__getURI;
                return soap_in_ns2__getURI(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURIResponse"))
              {
                *type = SOAP_TYPE_ns2__getURIResponse;
                return soap_in_ns2__getURIResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURL"))
              {
                *type = SOAP_TYPE_ns2__getURL;
                return soap_in_ns2__getURL(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getURLResponse"))
              {
                *type = SOAP_TYPE_ns2__getURLResponse;
                return soap_in_ns2__getURLResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getLocation"))
              {
                *type = SOAP_TYPE_ns2__getLocation;
                return soap_in_ns2__getLocation(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getLocationResponse"))
              {
                *type = SOAP_TYPE_ns2__getLocationResponse;
                return soap_in_ns2__getLocationResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getName"))
              {
                *type = SOAP_TYPE_ns2__getName;
                return soap_in_ns2__getName(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "ns2:getNameResponse"))
              {
                *type = SOAP_TYPE_ns2__getNameResponse;
                return soap_in_ns2__getNameResponse(soap, NULL, NULL, NULL);
              }
            if (!soap_match_tag(soap, t, "xsd:string"))
              {
                char **s;
                *type = SOAP_TYPE_string;
                s = soap_in_string(soap, NULL, NULL, NULL);
                return s ? *s : NULL;
              }
            t = soap->tag;
            if (!soap_match_tag(soap, t, "xsd:QName"))
              {
                char **s;
                *type = SOAP_TYPE__QName;
                s = soap_in__QName(soap, NULL, NULL, NULL);
                return s ? *s : NULL;
              }
          }
        }
      soap->error = SOAP_TAG_MISMATCH;
      return NULL;
    }

#ifdef __cplusplus
  }
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
  if (!soap_peek_element(soap))
    {
      int t;
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
      if (soap->mustUnderstand && !soap->other)
        return soap->error = SOAP_MUSTUNDERSTAND;
      if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
        {
          DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
          return soap->error = SOAP_TAG_MISMATCH;
        }
      if (!*soap->id || !soap_getelement(soap, &t))
        {
          soap->peeked = 0;
          if (soap->fignore)
            soap->error = soap->fignore(soap, soap->tag);
          else
            soap->error = SOAP_OK;
          DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
          if (!soap->error && soap->body)
            {
              soap->level++;
              while (!soap_ignore_element(soap))
;
              if (soap->error == SOAP_NO_TAG)
                soap->error = soap_element_end_in(soap, NULL);
            }
        }
    }
  return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
  int i;
  struct soap_plist *pp;
  if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
    for (i = 0; i < SOAP_PTRHASH; i++)
      for (pp = soap->pht[i]; pp; pp = pp->next)
        if (pp->mark1 == 2 || pp->mark2 == 2)
          if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
            return soap->error;
  return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C"
  {
#endif
    SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
    {
      switch (type)
        {
        case SOAP_TYPE_byte:
          return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
        case SOAP_TYPE_int:
          return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
        case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
          return ((ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_out(soap, tag, id, "xsd:string");
        case SOAP_TYPE_ns2__checkRegExp:
          return soap_out_ns2__checkRegExp(soap, tag, id, (const struct ns2__checkRegExp *)ptr, "ns2:checkRegExp");
        case SOAP_TYPE_ns2__checkRegExpResponse:
          return soap_out_ns2__checkRegExpResponse(soap, tag, id, (const struct ns2__checkRegExpResponse *)ptr, "ns2:checkRegExpResponse");
        case SOAP_TYPE_ns2__getDataTypesId:
          return soap_out_ns2__getDataTypesId(soap, tag, id, (const struct ns2__getDataTypesId *)ptr, "ns2:getDataTypesId");
        case SOAP_TYPE_ns2__getDataTypesIdResponse:
          return soap_out_ns2__getDataTypesIdResponse(soap, tag, id, (const struct ns2__getDataTypesIdResponse *)ptr, "ns2:getDataTypesIdResponse");
        case SOAP_TYPE_ns2__getDataTypesName:
          return soap_out_ns2__getDataTypesName(soap, tag, id, (const struct ns2__getDataTypesName *)ptr, "ns2:getDataTypesName");
        case SOAP_TYPE_ns2__getDataTypesNameResponse:
          return soap_out_ns2__getDataTypesNameResponse(soap, tag, id, (const struct ns2__getDataTypesNameResponse *)ptr, "ns2:getDataTypesNameResponse");
        case SOAP_TYPE_ns2__getNames:
          return soap_out_ns2__getNames(soap, tag, id, (const struct ns2__getNames *)ptr, "ns2:getNames");
        case SOAP_TYPE_ns2__getNamesResponse:
          return soap_out_ns2__getNamesResponse(soap, tag, id, (const struct ns2__getNamesResponse *)ptr, "ns2:getNamesResponse");
        case SOAP_TYPE_ns2__getDataTypeSynonyms:
          return soap_out_ns2__getDataTypeSynonyms(soap, tag, id, (const struct ns2__getDataTypeSynonyms *)ptr, "ns2:getDataTypeSynonyms");
        case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
          return soap_out_ns2__getDataTypeSynonymsResponse(soap, tag, id, (const struct ns2__getDataTypeSynonymsResponse *)ptr, "ns2:getDataTypeSynonymsResponse");
        case SOAP_TYPE_ns2__getResourceLocation:
          return soap_out_ns2__getResourceLocation(soap, tag, id, (const struct ns2__getResourceLocation *)ptr, "ns2:getResourceLocation");
        case SOAP_TYPE_ns2__getResourceLocationResponse:
          return soap_out_ns2__getResourceLocationResponse(soap, tag, id, (const struct ns2__getResourceLocationResponse *)ptr, "ns2:getResourceLocationResponse");
        case SOAP_TYPE_ns2__getResourceInstitution:
          return soap_out_ns2__getResourceInstitution(soap, tag, id, (const struct ns2__getResourceInstitution *)ptr, "ns2:getResourceInstitution");
        case SOAP_TYPE_ns2__getResourceInstitutionResponse:
          return soap_out_ns2__getResourceInstitutionResponse(soap, tag, id, (const struct ns2__getResourceInstitutionResponse *)ptr, "ns2:getResourceInstitutionResponse");
        case SOAP_TYPE_ns2__getResourceInfo:
          return soap_out_ns2__getResourceInfo(soap, tag, id, (const struct ns2__getResourceInfo *)ptr, "ns2:getResourceInfo");
        case SOAP_TYPE_ns2__getResourceInfoResponse:
          return soap_out_ns2__getResourceInfoResponse(soap, tag, id, (const struct ns2__getResourceInfoResponse *)ptr, "ns2:getResourceInfoResponse");
        case SOAP_TYPE_ns2__getDataTypePattern:
          return soap_out_ns2__getDataTypePattern(soap, tag, id, (const struct ns2__getDataTypePattern *)ptr, "ns2:getDataTypePattern");
        case SOAP_TYPE_ns2__getDataTypePatternResponse:
          return soap_out_ns2__getDataTypePatternResponse(soap, tag, id, (const struct ns2__getDataTypePatternResponse *)ptr, "ns2:getDataTypePatternResponse");
        case SOAP_TYPE_ns2__getMiriamURI:
          return soap_out_ns2__getMiriamURI(soap, tag, id, (const struct ns2__getMiriamURI *)ptr, "ns2:getMiriamURI");
        case SOAP_TYPE_ns2__getMiriamURIResponse:
          return soap_out_ns2__getMiriamURIResponse(soap, tag, id, (const struct ns2__getMiriamURIResponse *)ptr, "ns2:getMiriamURIResponse");
        case SOAP_TYPE_ns2__getOfficialDataTypeURI:
          return soap_out_ns2__getOfficialDataTypeURI(soap, tag, id, (const struct ns2__getOfficialDataTypeURI *)ptr, "ns2:getOfficialDataTypeURI");
        case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
          return soap_out_ns2__getOfficialDataTypeURIResponse(soap, tag, id, (const struct ns2__getOfficialDataTypeURIResponse *)ptr, "ns2:getOfficialDataTypeURIResponse");
        case SOAP_TYPE_ns2__getOfficialURI:
          return soap_out_ns2__getOfficialURI(soap, tag, id, (const struct ns2__getOfficialURI *)ptr, "ns2:getOfficialURI");
        case SOAP_TYPE_ns2__getOfficialURIResponse:
          return soap_out_ns2__getOfficialURIResponse(soap, tag, id, (const struct ns2__getOfficialURIResponse *)ptr, "ns2:getOfficialURIResponse");
        case SOAP_TYPE_ns2__isDeprecated:
          return soap_out_ns2__isDeprecated(soap, tag, id, (const struct ns2__isDeprecated *)ptr, "ns2:isDeprecated");
        case SOAP_TYPE_ns2__isDeprecatedResponse:
          return soap_out_ns2__isDeprecatedResponse(soap, tag, id, (const struct ns2__isDeprecatedResponse *)ptr, "ns2:isDeprecatedResponse");
        case SOAP_TYPE_ns2__getDataResources:
          return soap_out_ns2__getDataResources(soap, tag, id, (const struct ns2__getDataResources *)ptr, "ns2:getDataResources");
        case SOAP_TYPE_ns2__getDataResourcesResponse:
          return soap_out_ns2__getDataResourcesResponse(soap, tag, id, (const struct ns2__getDataResourcesResponse *)ptr, "ns2:getDataResourcesResponse");
        case SOAP_TYPE_ns2__getDataEntry:
          return soap_out_ns2__getDataEntry(soap, tag, id, (const struct ns2__getDataEntry *)ptr, "ns2:getDataEntry");
        case SOAP_TYPE_ns2__getDataEntryResponse:
          return soap_out_ns2__getDataEntryResponse(soap, tag, id, (const struct ns2__getDataEntryResponse *)ptr, "ns2:getDataEntryResponse");
        case SOAP_TYPE_ns2__getLocations_:
          return soap_out_ns2__getLocations_(soap, tag, id, (const struct ns2__getLocations_ *)ptr, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse_:
          return soap_out_ns2__getLocationsResponse_(soap, tag, id, (const struct ns2__getLocationsResponse_ *)ptr, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getLocations:
          return soap_out_ns2__getLocations(soap, tag, id, (const struct ns2__getLocations *)ptr, "ns2:getLocations");
        case SOAP_TYPE_ns2__getLocationsResponse:
          return soap_out_ns2__getLocationsResponse(soap, tag, id, (const struct ns2__getLocationsResponse *)ptr, "ns2:getLocationsResponse");
        case SOAP_TYPE_ns2__getDataEntries_:
          return soap_out_ns2__getDataEntries_(soap, tag, id, (const struct ns2__getDataEntries_ *)ptr, "ns2:getDataEntries");
        case SOAP_TYPE_ns2__getDataEntriesResponse_:
          return soap_out_ns2__getDataEntriesResponse_(soap, tag, id, (const struct ns2__getDataEntriesResponse_ *)ptr, "ns2:getDataEntriesResponse");
        case SOAP_TYPE_ns2__getDataEntries:
          return soap_out_ns2__getDataEntries(soap, tag, id, (const struct ns2__getDataEntries *)ptr, "ns2:getDataEntries");
        case SOAP_TYPE_ns2__getDataEntriesResponse:
          return soap_out_ns2__getDataEntriesResponse(soap, tag, id, (const struct ns2__getDataEntriesResponse *)ptr, "ns2:getDataEntriesResponse");
        case SOAP_TYPE_ns2__getDataTypeDef:
          return soap_out_ns2__getDataTypeDef(soap, tag, id, (const struct ns2__getDataTypeDef *)ptr, "ns2:getDataTypeDef");
        case SOAP_TYPE_ns2__getDataTypeDefResponse:
          return soap_out_ns2__getDataTypeDefResponse(soap, tag, id, (const struct ns2__getDataTypeDefResponse *)ptr, "ns2:getDataTypeDefResponse");
        case SOAP_TYPE_ns2__getURN:
          return soap_out_ns2__getURN(soap, tag, id, (const struct ns2__getURN *)ptr, "ns2:getURN");
        case SOAP_TYPE_ns2__getURNResponse:
          return soap_out_ns2__getURNResponse(soap, tag, id, (const struct ns2__getURNResponse *)ptr, "ns2:getURNResponse");
        case SOAP_TYPE_ns2__getDataTypeAllURIs:
          return soap_out_ns2__getDataTypeAllURIs(soap, tag, id, (const struct ns2__getDataTypeAllURIs *)ptr, "ns2:getDataTypeAllURIs");
        case SOAP_TYPE_ns2__getDataTypeAllURIsResponse:
          return soap_out_ns2__getDataTypeAllURIsResponse(soap, tag, id, (const struct ns2__getDataTypeAllURIsResponse *)ptr, "ns2:getDataTypeAllURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURIs_:
          return soap_out_ns2__getDataTypeURIs_(soap, tag, id, (const struct ns2__getDataTypeURIs_ *)ptr, "ns2:getDataTypeURIs");
        case SOAP_TYPE_ns2__getDataTypeURIsResponse_:
          return soap_out_ns2__getDataTypeURIsResponse_(soap, tag, id, (const struct ns2__getDataTypeURIsResponse_ *)ptr, "ns2:getDataTypeURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURIs:
          return soap_out_ns2__getDataTypeURIs(soap, tag, id, (const struct ns2__getDataTypeURIs *)ptr, "ns2:getDataTypeURIs");
        case SOAP_TYPE_ns2__getDataTypeURIsResponse:
          return soap_out_ns2__getDataTypeURIsResponse(soap, tag, id, (const struct ns2__getDataTypeURIsResponse *)ptr, "ns2:getDataTypeURIsResponse");
        case SOAP_TYPE_ns2__getDataTypeURI_:
          return soap_out_ns2__getDataTypeURI_(soap, tag, id, (const struct ns2__getDataTypeURI_ *)ptr, "ns2:getDataTypeURI");
        case SOAP_TYPE_ns2__getDataTypeURI_Response:
          return soap_out_ns2__getDataTypeURI_Response(soap, tag, id, (const struct ns2__getDataTypeURI_Response *)ptr, "ns2:getDataTypeURI-Response");
        case SOAP_TYPE_ns2__getDataTypeURI:
          return soap_out_ns2__getDataTypeURI(soap, tag, id, (const struct ns2__getDataTypeURI *)ptr, "ns2:getDataTypeURI");
        case SOAP_TYPE_ns2__getDataTypeURIResponse:
          return soap_out_ns2__getDataTypeURIResponse(soap, tag, id, (const struct ns2__getDataTypeURIResponse *)ptr, "ns2:getDataTypeURIResponse");
        case SOAP_TYPE_ns2__getDataTypeURLs:
          return soap_out_ns2__getDataTypeURLs(soap, tag, id, (const struct ns2__getDataTypeURLs *)ptr, "ns2:getDataTypeURLs");
        case SOAP_TYPE_ns2__getDataTypeURLsResponse:
          return soap_out_ns2__getDataTypeURLsResponse(soap, tag, id, (const struct ns2__getDataTypeURLsResponse *)ptr, "ns2:getDataTypeURLsResponse");
        case SOAP_TYPE_ns2__getDataTypeURL:
          return soap_out_ns2__getDataTypeURL(soap, tag, id, (const struct ns2__getDataTypeURL *)ptr, "ns2:getDataTypeURL");
        case SOAP_TYPE_ns2__getDataTypeURLResponse:
          return soap_out_ns2__getDataTypeURLResponse(soap, tag, id, (const struct ns2__getDataTypeURLResponse *)ptr, "ns2:getDataTypeURLResponse");
        case SOAP_TYPE_ns2__getDataTypeURNs:
          return soap_out_ns2__getDataTypeURNs(soap, tag, id, (const struct ns2__getDataTypeURNs *)ptr, "ns2:getDataTypeURNs");
        case SOAP_TYPE_ns2__getDataTypeURNsResponse:
          return soap_out_ns2__getDataTypeURNsResponse(soap, tag, id, (const struct ns2__getDataTypeURNsResponse *)ptr, "ns2:getDataTypeURNsResponse");
        case SOAP_TYPE_ns2__getDataTypeURN:
          return soap_out_ns2__getDataTypeURN(soap, tag, id, (const struct ns2__getDataTypeURN *)ptr, "ns2:getDataTypeURN");
        case SOAP_TYPE_ns2__getDataTypeURNResponse:
          return soap_out_ns2__getDataTypeURNResponse(soap, tag, id, (const struct ns2__getDataTypeURNResponse *)ptr, "ns2:getDataTypeURNResponse");
        case SOAP_TYPE_ns2__getJavaLibraryVersion:
          return soap_out_ns2__getJavaLibraryVersion(soap, tag, id, (const struct ns2__getJavaLibraryVersion *)ptr, "ns2:getJavaLibraryVersion");
        case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
          return soap_out_ns2__getJavaLibraryVersionResponse(soap, tag, id, (const struct ns2__getJavaLibraryVersionResponse *)ptr, "ns2:getJavaLibraryVersionResponse");
        case SOAP_TYPE_ns2__getServicesVersion:
          return soap_out_ns2__getServicesVersion(soap, tag, id, (const struct ns2__getServicesVersion *)ptr, "ns2:getServicesVersion");
        case SOAP_TYPE_ns2__getServicesVersionResponse:
          return soap_out_ns2__getServicesVersionResponse(soap, tag, id, (const struct ns2__getServicesVersionResponse *)ptr, "ns2:getServicesVersionResponse");
        case SOAP_TYPE_ns2__getServicesInfo:
          return soap_out_ns2__getServicesInfo(soap, tag, id, (const struct ns2__getServicesInfo *)ptr, "ns2:getServicesInfo");
        case SOAP_TYPE_ns2__getServicesInfoResponse:
          return soap_out_ns2__getServicesInfoResponse(soap, tag, id, (const struct ns2__getServicesInfoResponse *)ptr, "ns2:getServicesInfoResponse");
        case SOAP_TYPE_ns2__getURI_:
          return soap_out_ns2__getURI_(soap, tag, id, (const struct ns2__getURI_ *)ptr, "ns2:getURI");
        case SOAP_TYPE_ns2__getURI_Response:
          return soap_out_ns2__getURI_Response(soap, tag, id, (const struct ns2__getURI_Response *)ptr, "ns2:getURI-Response");
        case SOAP_TYPE_ns2__getURI:
          return soap_out_ns2__getURI(soap, tag, id, (const struct ns2__getURI *)ptr, "ns2:getURI");
        case SOAP_TYPE_ns2__getURIResponse:
          return soap_out_ns2__getURIResponse(soap, tag, id, (const struct ns2__getURIResponse *)ptr, "ns2:getURIResponse");
        case SOAP_TYPE_ns2__getURL:
          return soap_out_ns2__getURL(soap, tag, id, (const struct ns2__getURL *)ptr, "ns2:getURL");
        case SOAP_TYPE_ns2__getURLResponse:
          return soap_out_ns2__getURLResponse(soap, tag, id, (const struct ns2__getURLResponse *)ptr, "ns2:getURLResponse");
        case SOAP_TYPE_ns2__getLocation:
          return soap_out_ns2__getLocation(soap, tag, id, (const struct ns2__getLocation *)ptr, "ns2:getLocation");
        case SOAP_TYPE_ns2__getLocationResponse:
          return soap_out_ns2__getLocationResponse(soap, tag, id, (const struct ns2__getLocationResponse *)ptr, "ns2:getLocationResponse");
        case SOAP_TYPE_ns2__getName:
          return soap_out_ns2__getName(soap, tag, id, (const struct ns2__getName *)ptr, "ns2:getName");
        case SOAP_TYPE_ns2__getNameResponse:
          return soap_out_ns2__getNameResponse(soap, tag, id, (const struct ns2__getNameResponse *)ptr, "ns2:getNameResponse");
        case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
          return soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, id, (ArrayOf_USCORExsd_USCOREstring *const*)ptr, "xsd:string");
        case SOAP_TYPE_PointerTostring:
          return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
        case SOAP_TYPE__QName:
          return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
        case SOAP_TYPE_string:
          return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
        }
      return SOAP_OK;
    }

#ifdef __cplusplus
  }
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C"
  {
#endif
    SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
    {
      (void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
      switch (type)
        {
        case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
          ((ArrayOf_USCORExsd_USCOREstring *)ptr)->soap_serialize(soap);
          break;
        case SOAP_TYPE_ns2__checkRegExp:
          soap_serialize_ns2__checkRegExp(soap, (const struct ns2__checkRegExp *)ptr);
          break;
        case SOAP_TYPE_ns2__checkRegExpResponse:
          soap_serialize_ns2__checkRegExpResponse(soap, (const struct ns2__checkRegExpResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesId:
          soap_serialize_ns2__getDataTypesId(soap, (const struct ns2__getDataTypesId *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesIdResponse:
          soap_serialize_ns2__getDataTypesIdResponse(soap, (const struct ns2__getDataTypesIdResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesName:
          soap_serialize_ns2__getDataTypesName(soap, (const struct ns2__getDataTypesName *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypesNameResponse:
          soap_serialize_ns2__getDataTypesNameResponse(soap, (const struct ns2__getDataTypesNameResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getNames:
          soap_serialize_ns2__getNames(soap, (const struct ns2__getNames *)ptr);
          break;
        case SOAP_TYPE_ns2__getNamesResponse:
          soap_serialize_ns2__getNamesResponse(soap, (const struct ns2__getNamesResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeSynonyms:
          soap_serialize_ns2__getDataTypeSynonyms(soap, (const struct ns2__getDataTypeSynonyms *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
          soap_serialize_ns2__getDataTypeSynonymsResponse(soap, (const struct ns2__getDataTypeSynonymsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceLocation:
          soap_serialize_ns2__getResourceLocation(soap, (const struct ns2__getResourceLocation *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceLocationResponse:
          soap_serialize_ns2__getResourceLocationResponse(soap, (const struct ns2__getResourceLocationResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInstitution:
          soap_serialize_ns2__getResourceInstitution(soap, (const struct ns2__getResourceInstitution *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInstitutionResponse:
          soap_serialize_ns2__getResourceInstitutionResponse(soap, (const struct ns2__getResourceInstitutionResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInfo:
          soap_serialize_ns2__getResourceInfo(soap, (const struct ns2__getResourceInfo *)ptr);
          break;
        case SOAP_TYPE_ns2__getResourceInfoResponse:
          soap_serialize_ns2__getResourceInfoResponse(soap, (const struct ns2__getResourceInfoResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypePattern:
          soap_serialize_ns2__getDataTypePattern(soap, (const struct ns2__getDataTypePattern *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypePatternResponse:
          soap_serialize_ns2__getDataTypePatternResponse(soap, (const struct ns2__getDataTypePatternResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getMiriamURI:
          soap_serialize_ns2__getMiriamURI(soap, (const struct ns2__getMiriamURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getMiriamURIResponse:
          soap_serialize_ns2__getMiriamURIResponse(soap, (const struct ns2__getMiriamURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getOfficialDataTypeURI:
          soap_serialize_ns2__getOfficialDataTypeURI(soap, (const struct ns2__getOfficialDataTypeURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
          soap_serialize_ns2__getOfficialDataTypeURIResponse(soap, (const struct ns2__getOfficialDataTypeURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getOfficialURI:
          soap_serialize_ns2__getOfficialURI(soap, (const struct ns2__getOfficialURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getOfficialURIResponse:
          soap_serialize_ns2__getOfficialURIResponse(soap, (const struct ns2__getOfficialURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__isDeprecated:
          soap_serialize_ns2__isDeprecated(soap, (const struct ns2__isDeprecated *)ptr);
          break;
        case SOAP_TYPE_ns2__isDeprecatedResponse:
          soap_serialize_ns2__isDeprecatedResponse(soap, (const struct ns2__isDeprecatedResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataResources:
          soap_serialize_ns2__getDataResources(soap, (const struct ns2__getDataResources *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataResourcesResponse:
          soap_serialize_ns2__getDataResourcesResponse(soap, (const struct ns2__getDataResourcesResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataEntry:
          soap_serialize_ns2__getDataEntry(soap, (const struct ns2__getDataEntry *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataEntryResponse:
          soap_serialize_ns2__getDataEntryResponse(soap, (const struct ns2__getDataEntryResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocations_:
          soap_serialize_ns2__getLocations_(soap, (const struct ns2__getLocations_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocationsResponse_:
          soap_serialize_ns2__getLocationsResponse_(soap, (const struct ns2__getLocationsResponse_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocations:
          soap_serialize_ns2__getLocations(soap, (const struct ns2__getLocations *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocationsResponse:
          soap_serialize_ns2__getLocationsResponse(soap, (const struct ns2__getLocationsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataEntries_:
          soap_serialize_ns2__getDataEntries_(soap, (const struct ns2__getDataEntries_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataEntriesResponse_:
          soap_serialize_ns2__getDataEntriesResponse_(soap, (const struct ns2__getDataEntriesResponse_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataEntries:
          soap_serialize_ns2__getDataEntries(soap, (const struct ns2__getDataEntries *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataEntriesResponse:
          soap_serialize_ns2__getDataEntriesResponse(soap, (const struct ns2__getDataEntriesResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeDef:
          soap_serialize_ns2__getDataTypeDef(soap, (const struct ns2__getDataTypeDef *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeDefResponse:
          soap_serialize_ns2__getDataTypeDefResponse(soap, (const struct ns2__getDataTypeDefResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getURN:
          soap_serialize_ns2__getURN(soap, (const struct ns2__getURN *)ptr);
          break;
        case SOAP_TYPE_ns2__getURNResponse:
          soap_serialize_ns2__getURNResponse(soap, (const struct ns2__getURNResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeAllURIs:
          soap_serialize_ns2__getDataTypeAllURIs(soap, (const struct ns2__getDataTypeAllURIs *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeAllURIsResponse:
          soap_serialize_ns2__getDataTypeAllURIsResponse(soap, (const struct ns2__getDataTypeAllURIsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIs_:
          soap_serialize_ns2__getDataTypeURIs_(soap, (const struct ns2__getDataTypeURIs_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIsResponse_:
          soap_serialize_ns2__getDataTypeURIsResponse_(soap, (const struct ns2__getDataTypeURIsResponse_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIs:
          soap_serialize_ns2__getDataTypeURIs(soap, (const struct ns2__getDataTypeURIs *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIsResponse:
          soap_serialize_ns2__getDataTypeURIsResponse(soap, (const struct ns2__getDataTypeURIsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURI_:
          soap_serialize_ns2__getDataTypeURI_(soap, (const struct ns2__getDataTypeURI_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURI_Response:
          soap_serialize_ns2__getDataTypeURI_Response(soap, (const struct ns2__getDataTypeURI_Response *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURI:
          soap_serialize_ns2__getDataTypeURI(soap, (const struct ns2__getDataTypeURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURIResponse:
          soap_serialize_ns2__getDataTypeURIResponse(soap, (const struct ns2__getDataTypeURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURLs:
          soap_serialize_ns2__getDataTypeURLs(soap, (const struct ns2__getDataTypeURLs *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURLsResponse:
          soap_serialize_ns2__getDataTypeURLsResponse(soap, (const struct ns2__getDataTypeURLsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURL:
          soap_serialize_ns2__getDataTypeURL(soap, (const struct ns2__getDataTypeURL *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURLResponse:
          soap_serialize_ns2__getDataTypeURLResponse(soap, (const struct ns2__getDataTypeURLResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURNs:
          soap_serialize_ns2__getDataTypeURNs(soap, (const struct ns2__getDataTypeURNs *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURNsResponse:
          soap_serialize_ns2__getDataTypeURNsResponse(soap, (const struct ns2__getDataTypeURNsResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURN:
          soap_serialize_ns2__getDataTypeURN(soap, (const struct ns2__getDataTypeURN *)ptr);
          break;
        case SOAP_TYPE_ns2__getDataTypeURNResponse:
          soap_serialize_ns2__getDataTypeURNResponse(soap, (const struct ns2__getDataTypeURNResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getJavaLibraryVersion:
          soap_serialize_ns2__getJavaLibraryVersion(soap, (const struct ns2__getJavaLibraryVersion *)ptr);
          break;
        case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
          soap_serialize_ns2__getJavaLibraryVersionResponse(soap, (const struct ns2__getJavaLibraryVersionResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesVersion:
          soap_serialize_ns2__getServicesVersion(soap, (const struct ns2__getServicesVersion *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesVersionResponse:
          soap_serialize_ns2__getServicesVersionResponse(soap, (const struct ns2__getServicesVersionResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesInfo:
          soap_serialize_ns2__getServicesInfo(soap, (const struct ns2__getServicesInfo *)ptr);
          break;
        case SOAP_TYPE_ns2__getServicesInfoResponse:
          soap_serialize_ns2__getServicesInfoResponse(soap, (const struct ns2__getServicesInfoResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getURI_:
          soap_serialize_ns2__getURI_(soap, (const struct ns2__getURI_ *)ptr);
          break;
        case SOAP_TYPE_ns2__getURI_Response:
          soap_serialize_ns2__getURI_Response(soap, (const struct ns2__getURI_Response *)ptr);
          break;
        case SOAP_TYPE_ns2__getURI:
          soap_serialize_ns2__getURI(soap, (const struct ns2__getURI *)ptr);
          break;
        case SOAP_TYPE_ns2__getURIResponse:
          soap_serialize_ns2__getURIResponse(soap, (const struct ns2__getURIResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getURL:
          soap_serialize_ns2__getURL(soap, (const struct ns2__getURL *)ptr);
          break;
        case SOAP_TYPE_ns2__getURLResponse:
          soap_serialize_ns2__getURLResponse(soap, (const struct ns2__getURLResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocation:
          soap_serialize_ns2__getLocation(soap, (const struct ns2__getLocation *)ptr);
          break;
        case SOAP_TYPE_ns2__getLocationResponse:
          soap_serialize_ns2__getLocationResponse(soap, (const struct ns2__getLocationResponse *)ptr);
          break;
        case SOAP_TYPE_ns2__getName:
          soap_serialize_ns2__getName(soap, (const struct ns2__getName *)ptr);
          break;
        case SOAP_TYPE_ns2__getNameResponse:
          soap_serialize_ns2__getNameResponse(soap, (const struct ns2__getNameResponse *)ptr);
          break;
        case SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring:
          soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, (ArrayOf_USCORExsd_USCOREstring *const*)ptr);
          break;
        case SOAP_TYPE_PointerTostring:
          soap_serialize_PointerTostring(soap, (char **const*)ptr);
          break;
        case SOAP_TYPE__QName:
          soap_serialize_string(soap, (char*const*)&ptr);
          break;
        case SOAP_TYPE_string:
          soap_serialize_string(soap, (char*const*)&ptr);
          break;
        }
    }

#ifdef __cplusplus
  }
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
  switch (t)
    {
    case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
      return (void*)soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getNameResponse:
      return (void*)soap_instantiate_ns2__getNameResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getName:
      return (void*)soap_instantiate_ns2__getName(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getLocationResponse:
      return (void*)soap_instantiate_ns2__getLocationResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getLocation:
      return (void*)soap_instantiate_ns2__getLocation(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURLResponse:
      return (void*)soap_instantiate_ns2__getURLResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURL:
      return (void*)soap_instantiate_ns2__getURL(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURIResponse:
      return (void*)soap_instantiate_ns2__getURIResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURI:
      return (void*)soap_instantiate_ns2__getURI(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURI_Response:
      return (void*)soap_instantiate_ns2__getURI_Response(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURI_:
      return (void*)soap_instantiate_ns2__getURI_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getServicesInfoResponse:
      return (void*)soap_instantiate_ns2__getServicesInfoResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getServicesInfo:
      return (void*)soap_instantiate_ns2__getServicesInfo(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getServicesVersionResponse:
      return (void*)soap_instantiate_ns2__getServicesVersionResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getServicesVersion:
      return (void*)soap_instantiate_ns2__getServicesVersion(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
      return (void*)soap_instantiate_ns2__getJavaLibraryVersionResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getJavaLibraryVersion:
      return (void*)soap_instantiate_ns2__getJavaLibraryVersion(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURNResponse:
      return (void*)soap_instantiate_ns2__getDataTypeURNResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURN:
      return (void*)soap_instantiate_ns2__getDataTypeURN(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURNsResponse:
      return (void*)soap_instantiate_ns2__getDataTypeURNsResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURNs:
      return (void*)soap_instantiate_ns2__getDataTypeURNs(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURLResponse:
      return (void*)soap_instantiate_ns2__getDataTypeURLResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURL:
      return (void*)soap_instantiate_ns2__getDataTypeURL(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURLsResponse:
      return (void*)soap_instantiate_ns2__getDataTypeURLsResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURLs:
      return (void*)soap_instantiate_ns2__getDataTypeURLs(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURIResponse:
      return (void*)soap_instantiate_ns2__getDataTypeURIResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURI:
      return (void*)soap_instantiate_ns2__getDataTypeURI(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURI_Response:
      return (void*)soap_instantiate_ns2__getDataTypeURI_Response(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURI_:
      return (void*)soap_instantiate_ns2__getDataTypeURI_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURIsResponse:
      return (void*)soap_instantiate_ns2__getDataTypeURIsResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURIs:
      return (void*)soap_instantiate_ns2__getDataTypeURIs(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURIsResponse_:
      return (void*)soap_instantiate_ns2__getDataTypeURIsResponse_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeURIs_:
      return (void*)soap_instantiate_ns2__getDataTypeURIs_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeAllURIsResponse:
      return (void*)soap_instantiate_ns2__getDataTypeAllURIsResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeAllURIs:
      return (void*)soap_instantiate_ns2__getDataTypeAllURIs(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURNResponse:
      return (void*)soap_instantiate_ns2__getURNResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getURN:
      return (void*)soap_instantiate_ns2__getURN(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeDefResponse:
      return (void*)soap_instantiate_ns2__getDataTypeDefResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeDef:
      return (void*)soap_instantiate_ns2__getDataTypeDef(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataEntriesResponse:
      return (void*)soap_instantiate_ns2__getDataEntriesResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataEntries:
      return (void*)soap_instantiate_ns2__getDataEntries(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataEntriesResponse_:
      return (void*)soap_instantiate_ns2__getDataEntriesResponse_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataEntries_:
      return (void*)soap_instantiate_ns2__getDataEntries_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getLocationsResponse:
      return (void*)soap_instantiate_ns2__getLocationsResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getLocations:
      return (void*)soap_instantiate_ns2__getLocations(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getLocationsResponse_:
      return (void*)soap_instantiate_ns2__getLocationsResponse_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getLocations_:
      return (void*)soap_instantiate_ns2__getLocations_(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataEntryResponse:
      return (void*)soap_instantiate_ns2__getDataEntryResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataEntry:
      return (void*)soap_instantiate_ns2__getDataEntry(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataResourcesResponse:
      return (void*)soap_instantiate_ns2__getDataResourcesResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataResources:
      return (void*)soap_instantiate_ns2__getDataResources(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__isDeprecatedResponse:
      return (void*)soap_instantiate_ns2__isDeprecatedResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__isDeprecated:
      return (void*)soap_instantiate_ns2__isDeprecated(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getOfficialURIResponse:
      return (void*)soap_instantiate_ns2__getOfficialURIResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getOfficialURI:
      return (void*)soap_instantiate_ns2__getOfficialURI(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
      return (void*)soap_instantiate_ns2__getOfficialDataTypeURIResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getOfficialDataTypeURI:
      return (void*)soap_instantiate_ns2__getOfficialDataTypeURI(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getMiriamURIResponse:
      return (void*)soap_instantiate_ns2__getMiriamURIResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getMiriamURI:
      return (void*)soap_instantiate_ns2__getMiriamURI(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypePatternResponse:
      return (void*)soap_instantiate_ns2__getDataTypePatternResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypePattern:
      return (void*)soap_instantiate_ns2__getDataTypePattern(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getResourceInfoResponse:
      return (void*)soap_instantiate_ns2__getResourceInfoResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getResourceInfo:
      return (void*)soap_instantiate_ns2__getResourceInfo(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getResourceInstitutionResponse:
      return (void*)soap_instantiate_ns2__getResourceInstitutionResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getResourceInstitution:
      return (void*)soap_instantiate_ns2__getResourceInstitution(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getResourceLocationResponse:
      return (void*)soap_instantiate_ns2__getResourceLocationResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getResourceLocation:
      return (void*)soap_instantiate_ns2__getResourceLocation(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
      return (void*)soap_instantiate_ns2__getDataTypeSynonymsResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypeSynonyms:
      return (void*)soap_instantiate_ns2__getDataTypeSynonyms(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getNamesResponse:
      return (void*)soap_instantiate_ns2__getNamesResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getNames:
      return (void*)soap_instantiate_ns2__getNames(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypesNameResponse:
      return (void*)soap_instantiate_ns2__getDataTypesNameResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypesName:
      return (void*)soap_instantiate_ns2__getDataTypesName(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypesIdResponse:
      return (void*)soap_instantiate_ns2__getDataTypesIdResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__getDataTypesId:
      return (void*)soap_instantiate_ns2__getDataTypesId(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__checkRegExpResponse:
      return (void*)soap_instantiate_ns2__checkRegExpResponse(soap, -1, type, arrayType, n);
    case SOAP_TYPE_ns2__checkRegExp:
      return (void*)soap_instantiate_ns2__checkRegExp(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Header:
      return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Code:
      return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Detail:
      return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Reason:
      return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
    case SOAP_TYPE_SOAP_ENV__Fault:
      return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
    }
  return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{
  switch (p->type)
    {
    case SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring:
      if (p->size < 0)
        delete (ArrayOf_USCORExsd_USCOREstring*)p->ptr;
      else
        delete[] (ArrayOf_USCORExsd_USCOREstring*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getNameResponse:
      if (p->size < 0)
        delete (struct ns2__getNameResponse*)p->ptr;
      else
        delete[] (struct ns2__getNameResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getName:
      if (p->size < 0)
        delete (struct ns2__getName*)p->ptr;
      else
        delete[] (struct ns2__getName*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getLocationResponse:
      if (p->size < 0)
        delete (struct ns2__getLocationResponse*)p->ptr;
      else
        delete[] (struct ns2__getLocationResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getLocation:
      if (p->size < 0)
        delete (struct ns2__getLocation*)p->ptr;
      else
        delete[] (struct ns2__getLocation*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURLResponse:
      if (p->size < 0)
        delete (struct ns2__getURLResponse*)p->ptr;
      else
        delete[] (struct ns2__getURLResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURL:
      if (p->size < 0)
        delete (struct ns2__getURL*)p->ptr;
      else
        delete[] (struct ns2__getURL*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURIResponse:
      if (p->size < 0)
        delete (struct ns2__getURIResponse*)p->ptr;
      else
        delete[] (struct ns2__getURIResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURI:
      if (p->size < 0)
        delete (struct ns2__getURI*)p->ptr;
      else
        delete[] (struct ns2__getURI*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURI_Response:
      if (p->size < 0)
        delete (struct ns2__getURI_Response*)p->ptr;
      else
        delete[] (struct ns2__getURI_Response*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURI_:
      if (p->size < 0)
        delete (struct ns2__getURI_*)p->ptr;
      else
        delete[] (struct ns2__getURI_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getServicesInfoResponse:
      if (p->size < 0)
        delete (struct ns2__getServicesInfoResponse*)p->ptr;
      else
        delete[] (struct ns2__getServicesInfoResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getServicesInfo:
      if (p->size < 0)
        delete (struct ns2__getServicesInfo*)p->ptr;
      else
        delete[] (struct ns2__getServicesInfo*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getServicesVersionResponse:
      if (p->size < 0)
        delete (struct ns2__getServicesVersionResponse*)p->ptr;
      else
        delete[] (struct ns2__getServicesVersionResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getServicesVersion:
      if (p->size < 0)
        delete (struct ns2__getServicesVersion*)p->ptr;
      else
        delete[] (struct ns2__getServicesVersion*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getJavaLibraryVersionResponse:
      if (p->size < 0)
        delete (struct ns2__getJavaLibraryVersionResponse*)p->ptr;
      else
        delete[] (struct ns2__getJavaLibraryVersionResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getJavaLibraryVersion:
      if (p->size < 0)
        delete (struct ns2__getJavaLibraryVersion*)p->ptr;
      else
        delete[] (struct ns2__getJavaLibraryVersion*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURNResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURNResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURNResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURN:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURN*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURN*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURNsResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURNsResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURNsResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURNs:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURNs*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURNs*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURLResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURLResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURLResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURL:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURL*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURL*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURLsResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURLsResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURLsResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURLs:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURLs*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURLs*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURIResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURIResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURIResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURI:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURI*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURI*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURI_Response:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURI_Response*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURI_Response*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURI_:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURI_*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURI_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURIsResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURIsResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURIsResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURIs:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURIs*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURIs*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURIsResponse_:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURIsResponse_*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURIsResponse_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeURIs_:
      if (p->size < 0)
        delete (struct ns2__getDataTypeURIs_*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeURIs_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeAllURIsResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeAllURIsResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeAllURIsResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeAllURIs:
      if (p->size < 0)
        delete (struct ns2__getDataTypeAllURIs*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeAllURIs*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURNResponse:
      if (p->size < 0)
        delete (struct ns2__getURNResponse*)p->ptr;
      else
        delete[] (struct ns2__getURNResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getURN:
      if (p->size < 0)
        delete (struct ns2__getURN*)p->ptr;
      else
        delete[] (struct ns2__getURN*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeDefResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeDefResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeDefResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeDef:
      if (p->size < 0)
        delete (struct ns2__getDataTypeDef*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeDef*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataEntriesResponse:
      if (p->size < 0)
        delete (struct ns2__getDataEntriesResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataEntriesResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataEntries:
      if (p->size < 0)
        delete (struct ns2__getDataEntries*)p->ptr;
      else
        delete[] (struct ns2__getDataEntries*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataEntriesResponse_:
      if (p->size < 0)
        delete (struct ns2__getDataEntriesResponse_*)p->ptr;
      else
        delete[] (struct ns2__getDataEntriesResponse_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataEntries_:
      if (p->size < 0)
        delete (struct ns2__getDataEntries_*)p->ptr;
      else
        delete[] (struct ns2__getDataEntries_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getLocationsResponse:
      if (p->size < 0)
        delete (struct ns2__getLocationsResponse*)p->ptr;
      else
        delete[] (struct ns2__getLocationsResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getLocations:
      if (p->size < 0)
        delete (struct ns2__getLocations*)p->ptr;
      else
        delete[] (struct ns2__getLocations*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getLocationsResponse_:
      if (p->size < 0)
        delete (struct ns2__getLocationsResponse_*)p->ptr;
      else
        delete[] (struct ns2__getLocationsResponse_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getLocations_:
      if (p->size < 0)
        delete (struct ns2__getLocations_*)p->ptr;
      else
        delete[] (struct ns2__getLocations_*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataEntryResponse:
      if (p->size < 0)
        delete (struct ns2__getDataEntryResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataEntryResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataEntry:
      if (p->size < 0)
        delete (struct ns2__getDataEntry*)p->ptr;
      else
        delete[] (struct ns2__getDataEntry*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataResourcesResponse:
      if (p->size < 0)
        delete (struct ns2__getDataResourcesResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataResourcesResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataResources:
      if (p->size < 0)
        delete (struct ns2__getDataResources*)p->ptr;
      else
        delete[] (struct ns2__getDataResources*)p->ptr;
      break;
    case SOAP_TYPE_ns2__isDeprecatedResponse:
      if (p->size < 0)
        delete (struct ns2__isDeprecatedResponse*)p->ptr;
      else
        delete[] (struct ns2__isDeprecatedResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__isDeprecated:
      if (p->size < 0)
        delete (struct ns2__isDeprecated*)p->ptr;
      else
        delete[] (struct ns2__isDeprecated*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getOfficialURIResponse:
      if (p->size < 0)
        delete (struct ns2__getOfficialURIResponse*)p->ptr;
      else
        delete[] (struct ns2__getOfficialURIResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getOfficialURI:
      if (p->size < 0)
        delete (struct ns2__getOfficialURI*)p->ptr;
      else
        delete[] (struct ns2__getOfficialURI*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getOfficialDataTypeURIResponse:
      if (p->size < 0)
        delete (struct ns2__getOfficialDataTypeURIResponse*)p->ptr;
      else
        delete[] (struct ns2__getOfficialDataTypeURIResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getOfficialDataTypeURI:
      if (p->size < 0)
        delete (struct ns2__getOfficialDataTypeURI*)p->ptr;
      else
        delete[] (struct ns2__getOfficialDataTypeURI*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getMiriamURIResponse:
      if (p->size < 0)
        delete (struct ns2__getMiriamURIResponse*)p->ptr;
      else
        delete[] (struct ns2__getMiriamURIResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getMiriamURI:
      if (p->size < 0)
        delete (struct ns2__getMiriamURI*)p->ptr;
      else
        delete[] (struct ns2__getMiriamURI*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypePatternResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypePatternResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypePatternResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypePattern:
      if (p->size < 0)
        delete (struct ns2__getDataTypePattern*)p->ptr;
      else
        delete[] (struct ns2__getDataTypePattern*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getResourceInfoResponse:
      if (p->size < 0)
        delete (struct ns2__getResourceInfoResponse*)p->ptr;
      else
        delete[] (struct ns2__getResourceInfoResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getResourceInfo:
      if (p->size < 0)
        delete (struct ns2__getResourceInfo*)p->ptr;
      else
        delete[] (struct ns2__getResourceInfo*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getResourceInstitutionResponse:
      if (p->size < 0)
        delete (struct ns2__getResourceInstitutionResponse*)p->ptr;
      else
        delete[] (struct ns2__getResourceInstitutionResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getResourceInstitution:
      if (p->size < 0)
        delete (struct ns2__getResourceInstitution*)p->ptr;
      else
        delete[] (struct ns2__getResourceInstitution*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getResourceLocationResponse:
      if (p->size < 0)
        delete (struct ns2__getResourceLocationResponse*)p->ptr;
      else
        delete[] (struct ns2__getResourceLocationResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getResourceLocation:
      if (p->size < 0)
        delete (struct ns2__getResourceLocation*)p->ptr;
      else
        delete[] (struct ns2__getResourceLocation*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeSynonymsResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypeSynonymsResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeSynonymsResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypeSynonyms:
      if (p->size < 0)
        delete (struct ns2__getDataTypeSynonyms*)p->ptr;
      else
        delete[] (struct ns2__getDataTypeSynonyms*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getNamesResponse:
      if (p->size < 0)
        delete (struct ns2__getNamesResponse*)p->ptr;
      else
        delete[] (struct ns2__getNamesResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getNames:
      if (p->size < 0)
        delete (struct ns2__getNames*)p->ptr;
      else
        delete[] (struct ns2__getNames*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypesNameResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypesNameResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypesNameResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypesName:
      if (p->size < 0)
        delete (struct ns2__getDataTypesName*)p->ptr;
      else
        delete[] (struct ns2__getDataTypesName*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypesIdResponse:
      if (p->size < 0)
        delete (struct ns2__getDataTypesIdResponse*)p->ptr;
      else
        delete[] (struct ns2__getDataTypesIdResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__getDataTypesId:
      if (p->size < 0)
        delete (struct ns2__getDataTypesId*)p->ptr;
      else
        delete[] (struct ns2__getDataTypesId*)p->ptr;
      break;
    case SOAP_TYPE_ns2__checkRegExpResponse:
      if (p->size < 0)
        delete (struct ns2__checkRegExpResponse*)p->ptr;
      else
        delete[] (struct ns2__checkRegExpResponse*)p->ptr;
      break;
    case SOAP_TYPE_ns2__checkRegExp:
      if (p->size < 0)
        delete (struct ns2__checkRegExp*)p->ptr;
      else
        delete[] (struct ns2__checkRegExp*)p->ptr;
      break;
    case SOAP_TYPE_SOAP_ENV__Header:
      if (p->size < 0)
        delete (struct SOAP_ENV__Header*)p->ptr;
      else
        delete[] (struct SOAP_ENV__Header*)p->ptr;
      break;
    case SOAP_TYPE_SOAP_ENV__Code:
      if (p->size < 0)
        delete (struct SOAP_ENV__Code*)p->ptr;
      else
        delete[] (struct SOAP_ENV__Code*)p->ptr;
      break;
    case SOAP_TYPE_SOAP_ENV__Detail:
      if (p->size < 0)
        delete (struct SOAP_ENV__Detail*)p->ptr;
      else
        delete[] (struct SOAP_ENV__Detail*)p->ptr;
      break;
    case SOAP_TYPE_SOAP_ENV__Reason:
      if (p->size < 0)
        delete (struct SOAP_ENV__Reason*)p->ptr;
      else
        delete[] (struct SOAP_ENV__Reason*)p->ptr;
      break;
    case SOAP_TYPE_SOAP_ENV__Fault:
      if (p->size < 0)
        delete (struct SOAP_ENV__Fault*)p->ptr;
      else
        delete[] (struct SOAP_ENV__Fault*)p->ptr;
      break;
    default: return SOAP_ERR;
    }
  return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{
  return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
  *a = SOAP_DEFAULT_byte;
#else
  *a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
  if (soap_out_byte(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
  return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
  if ((p = soap_in_byte(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
  return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
  *a = SOAP_DEFAULT_int;
#else
  *a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
  if (soap_out_int(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
  return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
  if ((p = soap_in_int(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
  return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

void ArrayOf_USCORExsd_USCOREstring::soap_default(struct soap *soap)
{
  this->soap = soap;
  this->__size = 0;
  this->__ptr = NULL;
}

void ArrayOf_USCORExsd_USCOREstring::soap_serialize(struct soap *soap) const
  {
    if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring))
      for (int i = 0; i < this->__size; i++)
        {
          soap_serialize_string(soap, this->__ptr + i);
        }
  }

int ArrayOf_USCORExsd_USCOREstring::soap_put(struct soap *soap, const char *tag, const char *type) const
  {
    register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);
    if (this->soap_out(soap, tag, id, type))
      return soap->error;
    return soap_putindependent(soap);
  }

int ArrayOf_USCORExsd_USCOREstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
  {
    return soap_out_ArrayOf_USCORExsd_USCOREstring(soap, tag, id, this, type);
  }

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, const ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
  int i, n = a->__size;
  char *t = soap_putsize(soap, "xsd:string", a->__size);
  id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);
  if (id < 0)
    return soap->error;
  if (soap_array_begin_out(soap, tag, id, t, NULL))
    return soap->error;
  for (i = 0; i < n; i++)
    {
      soap->position = 1;
      soap->positions[0] = i;
      soap_out_string(soap, "item", -1, &a->__ptr[i], "");
    }
  soap->position = 0;
  return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCORExsd_USCOREstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
  return soap_get_ArrayOf_USCORExsd_USCOREstring(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_get_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *p, const char *tag, const char *type)
{
  if ((p = soap_in_ArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

void *ArrayOf_USCORExsd_USCOREstring::soap_in(struct soap *soap, const char *tag, const char *type)
{
  return soap_in_ArrayOf_USCORExsd_USCOREstring(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_in_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOf_USCORExsd_USCOREstring *a, const char *type)
{
  int i, j;
  char **p;
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (soap_match_array(soap, type))
    {
      soap->error = SOAP_TYPE;
      return NULL;
    }
  a = (ArrayOf_USCORExsd_USCOREstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOf_USCORExsd_USCOREstring), soap->type, soap->arrayType);
  if (!a)
    return NULL;
  if (soap->alloced)
    a->soap_default(soap);
  if (soap->body && !*soap->href)
    {
      a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
      if (a->__size >= 0)
        {
          a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
          for (i = 0; i < a->__size; i++)
            a->__ptr[i] = NULL;
          for (i = 0; i < a->__size; i++)
            {
              soap_peek_element(soap);
              if (soap->position)
                {
                  i = soap->positions[0] - j;
                  if (i < 0 || i >= a->__size)
                    {
                      soap->error = SOAP_IOB;
                      return NULL;
                    }
                }
              if (!soap_in_string(soap, NULL, a->__ptr + i, "xsd:string"))
                {
                  if (soap->error != SOAP_NO_TAG)
                    return NULL;
                  soap->error = SOAP_OK;
                  break;
                }
            }
        }
      else
        {
          if (soap_new_block(soap) == 0)
            return NULL;
          for (a->__size = 0; ; a->__size++)
            {
              p = (char **)soap_push_block(soap, sizeof(char *));
              if (!p)
                return NULL;
              *p = NULL;
              if (!soap_in_string(soap, NULL, p, "xsd:string"))
                {
                  if (soap->error != SOAP_NO_TAG)
                    return NULL;
                  soap->error = SOAP_OK;
                  break;
                }
            }
          soap_pop_block(soap);
          a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
          soap_save_block(soap, (char*)a->__ptr, 1);
        }
      if (soap_element_end_in(soap, tag))
        return NULL;
    }
  else
    {
      a = (ArrayOf_USCORExsd_USCOREstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, 0, sizeof(ArrayOf_USCORExsd_USCOREstring), 0, soap_copy_ArrayOf_USCORExsd_USCOREstring);
      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }
  return a;
}

SOAP_FMAC5 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC6 soap_new_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n)
{
  return soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring * SOAP_FMAC4 soap_instantiate_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCORExsd_USCOREstring(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
  struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, n, soap_fdelete);
  if (!cp)
    return NULL;
  if (n < 0)
    {
      cp->ptr = (void*)new ArrayOf_USCORExsd_USCOREstring;
      if (size)
        *size = sizeof(ArrayOf_USCORExsd_USCOREstring);
      ((ArrayOf_USCORExsd_USCOREstring*)cp->ptr)->soap = soap;
    }
  else
    {
      cp->ptr = (void*)new ArrayOf_USCORExsd_USCOREstring[n];
      if (!cp->ptr)
        {
          soap->error = SOAP_EOM;
          return NULL;
        }
      if (size)
        *size = n * sizeof(ArrayOf_USCORExsd_USCOREstring);
      for (int i = 0; i < n; i++)
        ((ArrayOf_USCORExsd_USCOREstring*)cp->ptr)[i].soap = soap;
    }
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
  return (ArrayOf_USCORExsd_USCOREstring*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCORExsd_USCOREstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCORExsd_USCOREstring %p -> %p\n", q, p));
  *(ArrayOf_USCORExsd_USCOREstring*)p = *(ArrayOf_USCORExsd_USCOREstring*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = NULL;
  a->SOAP_ENV__Code = NULL;
  a->SOAP_ENV__Reason = NULL;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->faultcode);
  soap_serialize_string(soap, &a->faultstring);
  soap_serialize_string(soap, &a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, &a->SOAP_ENV__Node);
  soap_serialize_string(soap, &a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
  if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
  const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
    return soap->error;
  if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
    return soap->error;
  if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
    return soap->error;
  if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
    return soap->error;
  if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
  {
    if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
  {
    size_t soap_flag_faultcode = 1;
    size_t soap_flag_faultstring = 1;
    size_t soap_flag_faultactor = 1;
    size_t soap_flag_detail = 1;
    size_t soap_flag_SOAP_ENV__Code = 1;
    size_t soap_flag_SOAP_ENV__Reason = 1;
    size_t soap_flag_SOAP_ENV__Node = 1;
    size_t soap_flag_SOAP_ENV__Role = 1;
    size_t soap_flag_SOAP_ENV__Detail = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_SOAP_ENV__Fault(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
                {
                  soap_flag_faultcode--;
                  continue;
                }
            if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
                {
                  soap_flag_faultstring--;
                  continue;
                }
            if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
                {
                  soap_flag_faultactor--;
                  continue;
                }
            if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
                {
                  soap_flag_detail--;
                  continue;
                }
            if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
                {
                  soap_flag_SOAP_ENV__Code--;
                  continue;
                }
            if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
                {
                  soap_flag_SOAP_ENV__Reason--;
                  continue;
                }
            if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
                {
                  soap_flag_SOAP_ENV__Node--;
                  continue;
                }
            if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
                {
                  soap_flag_SOAP_ENV__Role--;
                  continue;
                }
            if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
                {
                  soap_flag_SOAP_ENV__Detail--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
  {
    return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct SOAP_ENV__Fault;
        if (size)
          *size = sizeof(struct SOAP_ENV__Fault);
      }
    else
      {
        cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct SOAP_ENV__Fault);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Fault*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
  *(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
  if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
    return soap->error;
  // if (soap->lang)
  //  soap_set_attr(soap, "xml:lang", soap->lang);
  if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
  {
    if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
  {
    size_t soap_flag_SOAP_ENV__Text = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_SOAP_ENV__Reason(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
                {
                  soap_flag_SOAP_ENV__Text--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
  {
    return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct SOAP_ENV__Reason;
        if (size)
          *size = sizeof(struct SOAP_ENV__Reason);
      }
    else
      {
        cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct SOAP_ENV__Reason);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Reason*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
  *(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->__type = 0;
  a->fault = NULL;
  a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
  if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
    return soap->error;
  if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
    return soap->error;
  soap_outliteral(soap, "-any", &a->__any, NULL);
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
  {
    if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
  {
    size_t soap_flag_fault = 1;
    size_t soap_flag___any = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_SOAP_ENV__Detail(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
              if ((a->fault = soap_getelement(soap, &a->__type)))
                {
                  soap_flag_fault = 0;
                  continue;
                }
            if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_inliteral(soap, "-any", &a->__any))
                {
                  soap_flag___any--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
  {
    return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct SOAP_ENV__Detail;
        if (size)
          *size = sizeof(struct SOAP_ENV__Detail);
      }
    else
      {
        cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct SOAP_ENV__Detail);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Detail*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
  *(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default__QName(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize__QName(soap, &a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
  if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
  const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
    return soap->error;
  if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
    return soap->error;
  if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
  {
    if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
  {
    size_t soap_flag_SOAP_ENV__Value = 1;
    size_t soap_flag_SOAP_ENV__Subcode = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_SOAP_ENV__Code(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
                {
                  soap_flag_SOAP_ENV__Value--;
                  continue;
                }
            if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
                {
                  soap_flag_SOAP_ENV__Subcode--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
  {
    return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct SOAP_ENV__Code;
        if (size)
          *size = sizeof(struct SOAP_ENV__Code);
      }
    else
      {
        cp->ptr = (void*)new struct SOAP_ENV__Code[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct SOAP_ENV__Code);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Code*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
  *(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
  if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
  {
    if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_SOAP_ENV__Header(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
  {
    return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct SOAP_ENV__Header;
        if (size)
          *size = sizeof(struct SOAP_ENV__Header);
      }
    else
      {
        cp->ptr = (void*)new struct SOAP_ENV__Header[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct SOAP_ENV__Header);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct SOAP_ENV__Header*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
  *(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__checkRegExp(struct soap *soap, struct ns2__checkRegExp *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_identifier);
  soap_default_string(soap, &a->_datatype);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__checkRegExp(struct soap *soap, const struct ns2__checkRegExp *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_identifier);
  soap_serialize_string(soap, &a->_datatype);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__checkRegExp(struct soap *soap, const struct ns2__checkRegExp *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__checkRegExp);
  if (soap_out_ns2__checkRegExp(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__checkRegExp(struct soap *soap, const char *tag, int id, const struct ns2__checkRegExp *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__checkRegExp), type))
    return soap->error;
  if (soap_out_string(soap, "identifier", -1, &a->_identifier, ""))
    return soap->error;
  if (soap_out_string(soap, "datatype", -1, &a->_datatype, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__checkRegExp * SOAP_FMAC4 soap_get_ns2__checkRegExp(struct soap *soap, struct ns2__checkRegExp *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__checkRegExp(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__checkRegExp * SOAP_FMAC4 soap_in_ns2__checkRegExp(struct soap *soap, const char *tag, struct ns2__checkRegExp *a, const char *type)
  {
    size_t soap_flag__identifier = 1;
    size_t soap_flag__datatype = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__checkRegExp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__checkRegExp, sizeof(struct ns2__checkRegExp), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__checkRegExp(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_identifier, "xsd:string"))
                {
                  soap_flag__identifier--;
                  continue;
                }
            if (soap_flag__datatype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_datatype, "xsd:string"))
                {
                  soap_flag__datatype--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__checkRegExp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__checkRegExp, 0, sizeof(struct ns2__checkRegExp), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__checkRegExp * SOAP_FMAC6 soap_new_ns2__checkRegExp(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__checkRegExp(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__checkRegExp(struct soap *soap, struct ns2__checkRegExp *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__checkRegExp * SOAP_FMAC4 soap_instantiate_ns2__checkRegExp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__checkRegExp(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__checkRegExp, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__checkRegExp;
        if (size)
          *size = sizeof(struct ns2__checkRegExp);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__checkRegExp[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__checkRegExp);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__checkRegExp*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__checkRegExp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__checkRegExp %p -> %p\n", q, p));
  *(struct ns2__checkRegExp*)p = *(struct ns2__checkRegExp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__checkRegExpResponse(struct soap *soap, struct ns2__checkRegExpResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_checkRegExpReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__checkRegExpResponse(struct soap *soap, const struct ns2__checkRegExpResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_checkRegExpReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__checkRegExpResponse(struct soap *soap, const struct ns2__checkRegExpResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__checkRegExpResponse);
  if (soap_out_ns2__checkRegExpResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__checkRegExpResponse(struct soap *soap, const char *tag, int id, const struct ns2__checkRegExpResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__checkRegExpResponse), type))
    return soap->error;
  if (soap_out_string(soap, "checkRegExpReturn", -1, &a->_checkRegExpReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__checkRegExpResponse * SOAP_FMAC4 soap_get_ns2__checkRegExpResponse(struct soap *soap, struct ns2__checkRegExpResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__checkRegExpResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__checkRegExpResponse * SOAP_FMAC4 soap_in_ns2__checkRegExpResponse(struct soap *soap, const char *tag, struct ns2__checkRegExpResponse *a, const char *type)
  {
    size_t soap_flag__checkRegExpReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__checkRegExpResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__checkRegExpResponse, sizeof(struct ns2__checkRegExpResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__checkRegExpResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__checkRegExpReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_checkRegExpReturn, "xsd:string"))
                {
                  soap_flag__checkRegExpReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__checkRegExpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__checkRegExpResponse, 0, sizeof(struct ns2__checkRegExpResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__checkRegExpReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__checkRegExpResponse * SOAP_FMAC6 soap_new_ns2__checkRegExpResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__checkRegExpResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__checkRegExpResponse(struct soap *soap, struct ns2__checkRegExpResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__checkRegExpResponse * SOAP_FMAC4 soap_instantiate_ns2__checkRegExpResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__checkRegExpResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__checkRegExpResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__checkRegExpResponse;
        if (size)
          *size = sizeof(struct ns2__checkRegExpResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__checkRegExpResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__checkRegExpResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__checkRegExpResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__checkRegExpResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__checkRegExpResponse %p -> %p\n", q, p));
  *(struct ns2__checkRegExpResponse*)p = *(struct ns2__checkRegExpResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesId(struct soap *soap, struct ns2__getDataTypesId *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesId(struct soap *soap, const struct ns2__getDataTypesId *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesId(struct soap *soap, const struct ns2__getDataTypesId *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesId);
  if (soap_out_ns2__getDataTypesId(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesId(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesId *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesId), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesId * SOAP_FMAC4 soap_get_ns2__getDataTypesId(struct soap *soap, struct ns2__getDataTypesId *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypesId(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypesId * SOAP_FMAC4 soap_in_ns2__getDataTypesId(struct soap *soap, const char *tag, struct ns2__getDataTypesId *a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypesId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesId, sizeof(struct ns2__getDataTypesId), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypesId(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypesId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesId, 0, sizeof(struct ns2__getDataTypesId), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypesId * SOAP_FMAC6 soap_new_ns2__getDataTypesId(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypesId(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesId(struct soap *soap, struct ns2__getDataTypesId *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesId * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesId(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesId, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypesId;
        if (size)
          *size = sizeof(struct ns2__getDataTypesId);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypesId[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypesId);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypesId*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesId %p -> %p\n", q, p));
  *(struct ns2__getDataTypesId*)p = *(struct ns2__getDataTypesId*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesIdResponse(struct soap *soap, struct ns2__getDataTypesIdResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->getDataTypesIdReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesIdResponse(struct soap *soap, const struct ns2__getDataTypesIdResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->getDataTypesIdReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesIdResponse(struct soap *soap, const struct ns2__getDataTypesIdResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesIdResponse);
  if (soap_out_ns2__getDataTypesIdResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesIdResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesIdResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesIdResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesIdReturn", -1, &a->getDataTypesIdReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesIdResponse * SOAP_FMAC4 soap_get_ns2__getDataTypesIdResponse(struct soap *soap, struct ns2__getDataTypesIdResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypesIdResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypesIdResponse * SOAP_FMAC4 soap_in_ns2__getDataTypesIdResponse(struct soap *soap, const char *tag, struct ns2__getDataTypesIdResponse *a, const char *type)
  {
    size_t soap_flag_getDataTypesIdReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypesIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesIdResponse, sizeof(struct ns2__getDataTypesIdResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypesIdResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_getDataTypesIdReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesIdReturn", &a->getDataTypesIdReturn, "xsd:string"))
                {
                  soap_flag_getDataTypesIdReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypesIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesIdResponse, 0, sizeof(struct ns2__getDataTypesIdResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypesIdResponse * SOAP_FMAC6 soap_new_ns2__getDataTypesIdResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypesIdResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesIdResponse(struct soap *soap, struct ns2__getDataTypesIdResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesIdResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesIdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesIdResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesIdResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypesIdResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypesIdResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypesIdResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypesIdResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypesIdResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesIdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesIdResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypesIdResponse*)p = *(struct ns2__getDataTypesIdResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesName(struct soap *soap, struct ns2__getDataTypesName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesName(struct soap *soap, const struct ns2__getDataTypesName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesName(struct soap *soap, const struct ns2__getDataTypesName *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesName);
  if (soap_out_ns2__getDataTypesName(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesName(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesName *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesName), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesName * SOAP_FMAC4 soap_get_ns2__getDataTypesName(struct soap *soap, struct ns2__getDataTypesName *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypesName(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypesName * SOAP_FMAC4 soap_in_ns2__getDataTypesName(struct soap *soap, const char *tag, struct ns2__getDataTypesName *a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypesName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesName, sizeof(struct ns2__getDataTypesName), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypesName(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypesName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesName, 0, sizeof(struct ns2__getDataTypesName), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypesName * SOAP_FMAC6 soap_new_ns2__getDataTypesName(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypesName(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesName(struct soap *soap, struct ns2__getDataTypesName *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesName * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesName(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesName, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypesName;
        if (size)
          *size = sizeof(struct ns2__getDataTypesName);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypesName[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypesName);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypesName*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesName %p -> %p\n", q, p));
  *(struct ns2__getDataTypesName*)p = *(struct ns2__getDataTypesName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypesNameResponse(struct soap *soap, struct ns2__getDataTypesNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->getDataTypesNameReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypesNameResponse(struct soap *soap, const struct ns2__getDataTypesNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->getDataTypesNameReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypesNameResponse(struct soap *soap, const struct ns2__getDataTypesNameResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypesNameResponse);
  if (soap_out_ns2__getDataTypesNameResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypesNameResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypesNameResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypesNameResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesNameReturn", -1, &a->getDataTypesNameReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypesNameResponse * SOAP_FMAC4 soap_get_ns2__getDataTypesNameResponse(struct soap *soap, struct ns2__getDataTypesNameResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypesNameResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypesNameResponse * SOAP_FMAC4 soap_in_ns2__getDataTypesNameResponse(struct soap *soap, const char *tag, struct ns2__getDataTypesNameResponse *a, const char *type)
  {
    size_t soap_flag_getDataTypesNameReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypesNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypesNameResponse, sizeof(struct ns2__getDataTypesNameResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypesNameResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_getDataTypesNameReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypesNameReturn", &a->getDataTypesNameReturn, "xsd:string"))
                {
                  soap_flag_getDataTypesNameReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypesNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypesNameResponse, 0, sizeof(struct ns2__getDataTypesNameResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypesNameResponse * SOAP_FMAC6 soap_new_ns2__getDataTypesNameResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypesNameResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypesNameResponse(struct soap *soap, struct ns2__getDataTypesNameResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypesNameResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypesNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypesNameResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypesNameResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypesNameResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypesNameResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypesNameResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypesNameResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypesNameResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypesNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypesNameResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypesNameResponse*)p = *(struct ns2__getDataTypesNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getNames(struct soap *soap, struct ns2__getNames *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getNames(struct soap *soap, const struct ns2__getNames *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getNames(struct soap *soap, const struct ns2__getNames *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getNames);
  if (soap_out_ns2__getNames(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNames(struct soap *soap, const char *tag, int id, const struct ns2__getNames *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNames), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getNames * SOAP_FMAC4 soap_get_ns2__getNames(struct soap *soap, struct ns2__getNames *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getNames(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getNames * SOAP_FMAC4 soap_in_ns2__getNames(struct soap *soap, const char *tag, struct ns2__getNames *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getNames *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNames, sizeof(struct ns2__getNames), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getNames(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getNames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNames, 0, sizeof(struct ns2__getNames), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getNames * SOAP_FMAC6 soap_new_ns2__getNames(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getNames(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getNames(struct soap *soap, struct ns2__getNames *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getNames * SOAP_FMAC4 soap_instantiate_ns2__getNames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNames(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNames, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getNames;
        if (size)
          *size = sizeof(struct ns2__getNames);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getNames[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getNames);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getNames*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getNames %p -> %p\n", q, p));
  *(struct ns2__getNames*)p = *(struct ns2__getNames*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getNamesResponse(struct soap *soap, struct ns2__getNamesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getNamesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getNamesResponse(struct soap *soap, const struct ns2__getNamesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getNamesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getNamesResponse(struct soap *soap, const struct ns2__getNamesResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getNamesResponse);
  if (soap_out_ns2__getNamesResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNamesResponse(struct soap *soap, const char *tag, int id, const struct ns2__getNamesResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNamesResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getNamesReturn", -1, &a->_getNamesReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getNamesResponse * SOAP_FMAC4 soap_get_ns2__getNamesResponse(struct soap *soap, struct ns2__getNamesResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getNamesResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getNamesResponse * SOAP_FMAC4 soap_in_ns2__getNamesResponse(struct soap *soap, const char *tag, struct ns2__getNamesResponse *a, const char *type)
  {
    size_t soap_flag__getNamesReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getNamesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNamesResponse, sizeof(struct ns2__getNamesResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getNamesResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getNamesReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getNamesReturn, "xsd:string"))
                {
                  soap_flag__getNamesReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getNamesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNamesResponse, 0, sizeof(struct ns2__getNamesResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getNamesResponse * SOAP_FMAC6 soap_new_ns2__getNamesResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getNamesResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getNamesResponse(struct soap *soap, struct ns2__getNamesResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getNamesResponse * SOAP_FMAC4 soap_instantiate_ns2__getNamesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNamesResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNamesResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getNamesResponse;
        if (size)
          *size = sizeof(struct ns2__getNamesResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getNamesResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getNamesResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getNamesResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNamesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getNamesResponse %p -> %p\n", q, p));
  *(struct ns2__getNamesResponse*)p = *(struct ns2__getNamesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeSynonyms(struct soap *soap, struct ns2__getDataTypeSynonyms *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeSynonyms(struct soap *soap, const struct ns2__getDataTypeSynonyms *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeSynonyms(struct soap *soap, const struct ns2__getDataTypeSynonyms *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeSynonyms);
  if (soap_out_ns2__getDataTypeSynonyms(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeSynonyms(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeSynonyms *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeSynonyms), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonyms * SOAP_FMAC4 soap_get_ns2__getDataTypeSynonyms(struct soap *soap, struct ns2__getDataTypeSynonyms *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeSynonyms(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeSynonyms * SOAP_FMAC4 soap_in_ns2__getDataTypeSynonyms(struct soap *soap, const char *tag, struct ns2__getDataTypeSynonyms *a, const char *type)
  {
    size_t soap_flag__name = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeSynonyms *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeSynonyms, sizeof(struct ns2__getDataTypeSynonyms), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeSynonyms(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeSynonyms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeSynonyms, 0, sizeof(struct ns2__getDataTypeSynonyms), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeSynonyms * SOAP_FMAC6 soap_new_ns2__getDataTypeSynonyms(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeSynonyms(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeSynonyms(struct soap *soap, struct ns2__getDataTypeSynonyms *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonyms * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeSynonyms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeSynonyms(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeSynonyms, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeSynonyms;
        if (size)
          *size = sizeof(struct ns2__getDataTypeSynonyms);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeSynonyms[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeSynonyms);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeSynonyms*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeSynonyms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeSynonyms %p -> %p\n", q, p));
  *(struct ns2__getDataTypeSynonyms*)p = *(struct ns2__getDataTypeSynonyms*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeSynonymsResponse(struct soap *soap, struct ns2__getDataTypeSynonymsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeSynonymsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeSynonymsResponse(struct soap *soap, const struct ns2__getDataTypeSynonymsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeSynonymsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeSynonymsResponse(struct soap *soap, const struct ns2__getDataTypeSynonymsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeSynonymsResponse);
  if (soap_out_ns2__getDataTypeSynonymsResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeSynonymsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeSynonymsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeSynonymsResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeSynonymsReturn", -1, &a->_getDataTypeSynonymsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeSynonymsResponse(struct soap *soap, struct ns2__getDataTypeSynonymsResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeSynonymsResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeSynonymsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeSynonymsResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeSynonymsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeSynonymsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeSynonymsResponse, sizeof(struct ns2__getDataTypeSynonymsResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeSynonymsResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeSynonymsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeSynonymsReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeSynonymsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeSynonymsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeSynonymsResponse, 0, sizeof(struct ns2__getDataTypeSynonymsResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeSynonymsResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeSynonymsResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeSynonymsResponse(struct soap *soap, struct ns2__getDataTypeSynonymsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeSynonymsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeSynonymsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeSynonymsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeSynonymsResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeSynonymsResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeSynonymsResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeSynonymsResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeSynonymsResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeSynonymsResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeSynonymsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeSynonymsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeSynonymsResponse*)p = *(struct ns2__getDataTypeSynonymsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceLocation(struct soap *soap, struct ns2__getResourceLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceLocation(struct soap *soap, const struct ns2__getResourceLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceLocation(struct soap *soap, const struct ns2__getResourceLocation *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceLocation);
  if (soap_out_ns2__getResourceLocation(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceLocation(struct soap *soap, const char *tag, int id, const struct ns2__getResourceLocation *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceLocation), type))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceLocation * SOAP_FMAC4 soap_get_ns2__getResourceLocation(struct soap *soap, struct ns2__getResourceLocation *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getResourceLocation(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getResourceLocation * SOAP_FMAC4 soap_in_ns2__getResourceLocation(struct soap *soap, const char *tag, struct ns2__getResourceLocation *a, const char *type)
  {
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getResourceLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceLocation, sizeof(struct ns2__getResourceLocation), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getResourceLocation(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getResourceLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceLocation, 0, sizeof(struct ns2__getResourceLocation), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getResourceLocation * SOAP_FMAC6 soap_new_ns2__getResourceLocation(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getResourceLocation(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceLocation(struct soap *soap, struct ns2__getResourceLocation *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceLocation * SOAP_FMAC4 soap_instantiate_ns2__getResourceLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceLocation(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceLocation, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getResourceLocation;
        if (size)
          *size = sizeof(struct ns2__getResourceLocation);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getResourceLocation[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getResourceLocation);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getResourceLocation*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceLocation %p -> %p\n", q, p));
  *(struct ns2__getResourceLocation*)p = *(struct ns2__getResourceLocation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceLocationResponse(struct soap *soap, struct ns2__getResourceLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getResourceLocationReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceLocationResponse(struct soap *soap, const struct ns2__getResourceLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getResourceLocationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceLocationResponse(struct soap *soap, const struct ns2__getResourceLocationResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceLocationResponse);
  if (soap_out_ns2__getResourceLocationResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceLocationResponse(struct soap *soap, const char *tag, int id, const struct ns2__getResourceLocationResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceLocationResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getResourceLocationReturn", -1, &a->_getResourceLocationReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceLocationResponse * SOAP_FMAC4 soap_get_ns2__getResourceLocationResponse(struct soap *soap, struct ns2__getResourceLocationResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getResourceLocationResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getResourceLocationResponse * SOAP_FMAC4 soap_in_ns2__getResourceLocationResponse(struct soap *soap, const char *tag, struct ns2__getResourceLocationResponse *a, const char *type)
  {
    size_t soap_flag__getResourceLocationReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getResourceLocationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceLocationResponse, sizeof(struct ns2__getResourceLocationResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getResourceLocationResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getResourceLocationReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getResourceLocationReturn, "xsd:string"))
                {
                  soap_flag__getResourceLocationReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getResourceLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceLocationResponse, 0, sizeof(struct ns2__getResourceLocationResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getResourceLocationReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getResourceLocationResponse * SOAP_FMAC6 soap_new_ns2__getResourceLocationResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getResourceLocationResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceLocationResponse(struct soap *soap, struct ns2__getResourceLocationResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceLocationResponse * SOAP_FMAC4 soap_instantiate_ns2__getResourceLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceLocationResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceLocationResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getResourceLocationResponse;
        if (size)
          *size = sizeof(struct ns2__getResourceLocationResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getResourceLocationResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getResourceLocationResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getResourceLocationResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceLocationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceLocationResponse %p -> %p\n", q, p));
  *(struct ns2__getResourceLocationResponse*)p = *(struct ns2__getResourceLocationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInstitution(struct soap *soap, struct ns2__getResourceInstitution *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInstitution(struct soap *soap, const struct ns2__getResourceInstitution *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInstitution(struct soap *soap, const struct ns2__getResourceInstitution *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInstitution);
  if (soap_out_ns2__getResourceInstitution(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInstitution(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInstitution *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInstitution), type))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInstitution * SOAP_FMAC4 soap_get_ns2__getResourceInstitution(struct soap *soap, struct ns2__getResourceInstitution *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getResourceInstitution(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getResourceInstitution * SOAP_FMAC4 soap_in_ns2__getResourceInstitution(struct soap *soap, const char *tag, struct ns2__getResourceInstitution *a, const char *type)
  {
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getResourceInstitution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInstitution, sizeof(struct ns2__getResourceInstitution), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getResourceInstitution(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getResourceInstitution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInstitution, 0, sizeof(struct ns2__getResourceInstitution), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getResourceInstitution * SOAP_FMAC6 soap_new_ns2__getResourceInstitution(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getResourceInstitution(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInstitution(struct soap *soap, struct ns2__getResourceInstitution *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInstitution * SOAP_FMAC4 soap_instantiate_ns2__getResourceInstitution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInstitution(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInstitution, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getResourceInstitution;
        if (size)
          *size = sizeof(struct ns2__getResourceInstitution);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getResourceInstitution[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getResourceInstitution);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getResourceInstitution*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInstitution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInstitution %p -> %p\n", q, p));
  *(struct ns2__getResourceInstitution*)p = *(struct ns2__getResourceInstitution*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInstitutionResponse(struct soap *soap, struct ns2__getResourceInstitutionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getResourceInstitutionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInstitutionResponse(struct soap *soap, const struct ns2__getResourceInstitutionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getResourceInstitutionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInstitutionResponse(struct soap *soap, const struct ns2__getResourceInstitutionResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInstitutionResponse);
  if (soap_out_ns2__getResourceInstitutionResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInstitutionResponse(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInstitutionResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInstitutionResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getResourceInstitutionReturn", -1, &a->_getResourceInstitutionReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInstitutionResponse * SOAP_FMAC4 soap_get_ns2__getResourceInstitutionResponse(struct soap *soap, struct ns2__getResourceInstitutionResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getResourceInstitutionResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getResourceInstitutionResponse * SOAP_FMAC4 soap_in_ns2__getResourceInstitutionResponse(struct soap *soap, const char *tag, struct ns2__getResourceInstitutionResponse *a, const char *type)
  {
    size_t soap_flag__getResourceInstitutionReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getResourceInstitutionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInstitutionResponse, sizeof(struct ns2__getResourceInstitutionResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getResourceInstitutionResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getResourceInstitutionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getResourceInstitutionReturn, "xsd:string"))
                {
                  soap_flag__getResourceInstitutionReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getResourceInstitutionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInstitutionResponse, 0, sizeof(struct ns2__getResourceInstitutionResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getResourceInstitutionReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getResourceInstitutionResponse * SOAP_FMAC6 soap_new_ns2__getResourceInstitutionResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getResourceInstitutionResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInstitutionResponse(struct soap *soap, struct ns2__getResourceInstitutionResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInstitutionResponse * SOAP_FMAC4 soap_instantiate_ns2__getResourceInstitutionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInstitutionResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInstitutionResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getResourceInstitutionResponse;
        if (size)
          *size = sizeof(struct ns2__getResourceInstitutionResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getResourceInstitutionResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getResourceInstitutionResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getResourceInstitutionResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInstitutionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInstitutionResponse %p -> %p\n", q, p));
  *(struct ns2__getResourceInstitutionResponse*)p = *(struct ns2__getResourceInstitutionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInfo(struct soap *soap, struct ns2__getResourceInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInfo(struct soap *soap, const struct ns2__getResourceInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInfo(struct soap *soap, const struct ns2__getResourceInfo *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInfo);
  if (soap_out_ns2__getResourceInfo(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInfo(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInfo *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInfo), type))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInfo * SOAP_FMAC4 soap_get_ns2__getResourceInfo(struct soap *soap, struct ns2__getResourceInfo *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getResourceInfo(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getResourceInfo * SOAP_FMAC4 soap_in_ns2__getResourceInfo(struct soap *soap, const char *tag, struct ns2__getResourceInfo *a, const char *type)
  {
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getResourceInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInfo, sizeof(struct ns2__getResourceInfo), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getResourceInfo(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getResourceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInfo, 0, sizeof(struct ns2__getResourceInfo), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getResourceInfo * SOAP_FMAC6 soap_new_ns2__getResourceInfo(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getResourceInfo(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInfo(struct soap *soap, struct ns2__getResourceInfo *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInfo * SOAP_FMAC4 soap_instantiate_ns2__getResourceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInfo(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInfo, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getResourceInfo;
        if (size)
          *size = sizeof(struct ns2__getResourceInfo);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getResourceInfo[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getResourceInfo);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getResourceInfo*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInfo %p -> %p\n", q, p));
  *(struct ns2__getResourceInfo*)p = *(struct ns2__getResourceInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getResourceInfoResponse(struct soap *soap, struct ns2__getResourceInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getResourceInfoReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getResourceInfoResponse(struct soap *soap, const struct ns2__getResourceInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getResourceInfoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getResourceInfoResponse(struct soap *soap, const struct ns2__getResourceInfoResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getResourceInfoResponse);
  if (soap_out_ns2__getResourceInfoResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getResourceInfoResponse(struct soap *soap, const char *tag, int id, const struct ns2__getResourceInfoResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getResourceInfoResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getResourceInfoReturn", -1, &a->_getResourceInfoReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getResourceInfoResponse * SOAP_FMAC4 soap_get_ns2__getResourceInfoResponse(struct soap *soap, struct ns2__getResourceInfoResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getResourceInfoResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getResourceInfoResponse * SOAP_FMAC4 soap_in_ns2__getResourceInfoResponse(struct soap *soap, const char *tag, struct ns2__getResourceInfoResponse *a, const char *type)
  {
    size_t soap_flag__getResourceInfoReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getResourceInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getResourceInfoResponse, sizeof(struct ns2__getResourceInfoResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getResourceInfoResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getResourceInfoReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getResourceInfoReturn, "xsd:string"))
                {
                  soap_flag__getResourceInfoReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getResourceInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getResourceInfoResponse, 0, sizeof(struct ns2__getResourceInfoResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getResourceInfoReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getResourceInfoResponse * SOAP_FMAC6 soap_new_ns2__getResourceInfoResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getResourceInfoResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getResourceInfoResponse(struct soap *soap, struct ns2__getResourceInfoResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getResourceInfoResponse * SOAP_FMAC4 soap_instantiate_ns2__getResourceInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getResourceInfoResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getResourceInfoResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getResourceInfoResponse;
        if (size)
          *size = sizeof(struct ns2__getResourceInfoResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getResourceInfoResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getResourceInfoResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getResourceInfoResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getResourceInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getResourceInfoResponse %p -> %p\n", q, p));
  *(struct ns2__getResourceInfoResponse*)p = *(struct ns2__getResourceInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypePattern(struct soap *soap, struct ns2__getDataTypePattern *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypePattern(struct soap *soap, const struct ns2__getDataTypePattern *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypePattern(struct soap *soap, const struct ns2__getDataTypePattern *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypePattern);
  if (soap_out_ns2__getDataTypePattern(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypePattern(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypePattern *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypePattern), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypePattern * SOAP_FMAC4 soap_get_ns2__getDataTypePattern(struct soap *soap, struct ns2__getDataTypePattern *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypePattern(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypePattern * SOAP_FMAC4 soap_in_ns2__getDataTypePattern(struct soap *soap, const char *tag, struct ns2__getDataTypePattern *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypePattern *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypePattern, sizeof(struct ns2__getDataTypePattern), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypePattern(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypePattern *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypePattern, 0, sizeof(struct ns2__getDataTypePattern), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypePattern * SOAP_FMAC6 soap_new_ns2__getDataTypePattern(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypePattern(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypePattern(struct soap *soap, struct ns2__getDataTypePattern *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypePattern * SOAP_FMAC4 soap_instantiate_ns2__getDataTypePattern(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypePattern(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypePattern, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypePattern;
        if (size)
          *size = sizeof(struct ns2__getDataTypePattern);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypePattern[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypePattern);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypePattern*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypePattern(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypePattern %p -> %p\n", q, p));
  *(struct ns2__getDataTypePattern*)p = *(struct ns2__getDataTypePattern*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypePatternResponse(struct soap *soap, struct ns2__getDataTypePatternResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataTypePatternReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypePatternResponse(struct soap *soap, const struct ns2__getDataTypePatternResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataTypePatternReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypePatternResponse(struct soap *soap, const struct ns2__getDataTypePatternResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypePatternResponse);
  if (soap_out_ns2__getDataTypePatternResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypePatternResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypePatternResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypePatternResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getDataTypePatternReturn", -1, &a->_getDataTypePatternReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypePatternResponse * SOAP_FMAC4 soap_get_ns2__getDataTypePatternResponse(struct soap *soap, struct ns2__getDataTypePatternResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypePatternResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypePatternResponse * SOAP_FMAC4 soap_in_ns2__getDataTypePatternResponse(struct soap *soap, const char *tag, struct ns2__getDataTypePatternResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypePatternReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypePatternResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypePatternResponse, sizeof(struct ns2__getDataTypePatternResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypePatternResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypePatternReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataTypePatternReturn, "xsd:string"))
                {
                  soap_flag__getDataTypePatternReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypePatternResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypePatternResponse, 0, sizeof(struct ns2__getDataTypePatternResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypePatternReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypePatternResponse * SOAP_FMAC6 soap_new_ns2__getDataTypePatternResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypePatternResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypePatternResponse(struct soap *soap, struct ns2__getDataTypePatternResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypePatternResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypePatternResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypePatternResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypePatternResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypePatternResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypePatternResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypePatternResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypePatternResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypePatternResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypePatternResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypePatternResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypePatternResponse*)p = *(struct ns2__getDataTypePatternResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getMiriamURI(struct soap *soap, struct ns2__getMiriamURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getMiriamURI(struct soap *soap, const struct ns2__getMiriamURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getMiriamURI(struct soap *soap, const struct ns2__getMiriamURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getMiriamURI);
  if (soap_out_ns2__getMiriamURI(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMiriamURI(struct soap *soap, const char *tag, int id, const struct ns2__getMiriamURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMiriamURI), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getMiriamURI * SOAP_FMAC4 soap_get_ns2__getMiriamURI(struct soap *soap, struct ns2__getMiriamURI *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getMiriamURI(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getMiriamURI * SOAP_FMAC4 soap_in_ns2__getMiriamURI(struct soap *soap, const char *tag, struct ns2__getMiriamURI *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getMiriamURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMiriamURI, sizeof(struct ns2__getMiriamURI), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getMiriamURI(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getMiriamURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMiriamURI, 0, sizeof(struct ns2__getMiriamURI), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getMiriamURI * SOAP_FMAC6 soap_new_ns2__getMiriamURI(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getMiriamURI(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getMiriamURI(struct soap *soap, struct ns2__getMiriamURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getMiriamURI * SOAP_FMAC4 soap_instantiate_ns2__getMiriamURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMiriamURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMiriamURI, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getMiriamURI;
        if (size)
          *size = sizeof(struct ns2__getMiriamURI);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getMiriamURI[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getMiriamURI);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getMiriamURI*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMiriamURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getMiriamURI %p -> %p\n", q, p));
  *(struct ns2__getMiriamURI*)p = *(struct ns2__getMiriamURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getMiriamURIResponse(struct soap *soap, struct ns2__getMiriamURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getMiriamURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getMiriamURIResponse(struct soap *soap, const struct ns2__getMiriamURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getMiriamURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getMiriamURIResponse(struct soap *soap, const struct ns2__getMiriamURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getMiriamURIResponse);
  if (soap_out_ns2__getMiriamURIResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getMiriamURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getMiriamURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getMiriamURIResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getMiriamURIReturn", -1, &a->_getMiriamURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getMiriamURIResponse * SOAP_FMAC4 soap_get_ns2__getMiriamURIResponse(struct soap *soap, struct ns2__getMiriamURIResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getMiriamURIResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getMiriamURIResponse * SOAP_FMAC4 soap_in_ns2__getMiriamURIResponse(struct soap *soap, const char *tag, struct ns2__getMiriamURIResponse *a, const char *type)
  {
    size_t soap_flag__getMiriamURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getMiriamURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getMiriamURIResponse, sizeof(struct ns2__getMiriamURIResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getMiriamURIResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getMiriamURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getMiriamURIReturn, "xsd:string"))
                {
                  soap_flag__getMiriamURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getMiriamURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getMiriamURIResponse, 0, sizeof(struct ns2__getMiriamURIResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getMiriamURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getMiriamURIResponse * SOAP_FMAC6 soap_new_ns2__getMiriamURIResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getMiriamURIResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getMiriamURIResponse(struct soap *soap, struct ns2__getMiriamURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getMiriamURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getMiriamURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getMiriamURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getMiriamURIResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getMiriamURIResponse;
        if (size)
          *size = sizeof(struct ns2__getMiriamURIResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getMiriamURIResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getMiriamURIResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getMiriamURIResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getMiriamURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getMiriamURIResponse %p -> %p\n", q, p));
  *(struct ns2__getMiriamURIResponse*)p = *(struct ns2__getMiriamURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getOfficialDataTypeURI(struct soap *soap, struct ns2__getOfficialDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getOfficialDataTypeURI(struct soap *soap, const struct ns2__getOfficialDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getOfficialDataTypeURI(struct soap *soap, const struct ns2__getOfficialDataTypeURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getOfficialDataTypeURI);
  if (soap_out_ns2__getOfficialDataTypeURI(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOfficialDataTypeURI(struct soap *soap, const char *tag, int id, const struct ns2__getOfficialDataTypeURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOfficialDataTypeURI), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURI * SOAP_FMAC4 soap_get_ns2__getOfficialDataTypeURI(struct soap *soap, struct ns2__getOfficialDataTypeURI *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getOfficialDataTypeURI(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getOfficialDataTypeURI * SOAP_FMAC4 soap_in_ns2__getOfficialDataTypeURI(struct soap *soap, const char *tag, struct ns2__getOfficialDataTypeURI *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getOfficialDataTypeURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOfficialDataTypeURI, sizeof(struct ns2__getOfficialDataTypeURI), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getOfficialDataTypeURI(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getOfficialDataTypeURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOfficialDataTypeURI, 0, sizeof(struct ns2__getOfficialDataTypeURI), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getOfficialDataTypeURI * SOAP_FMAC6 soap_new_ns2__getOfficialDataTypeURI(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getOfficialDataTypeURI(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getOfficialDataTypeURI(struct soap *soap, struct ns2__getOfficialDataTypeURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURI * SOAP_FMAC4 soap_instantiate_ns2__getOfficialDataTypeURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOfficialDataTypeURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getOfficialDataTypeURI, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getOfficialDataTypeURI;
        if (size)
          *size = sizeof(struct ns2__getOfficialDataTypeURI);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getOfficialDataTypeURI[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getOfficialDataTypeURI);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getOfficialDataTypeURI*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getOfficialDataTypeURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getOfficialDataTypeURI %p -> %p\n", q, p));
  *(struct ns2__getOfficialDataTypeURI*)p = *(struct ns2__getOfficialDataTypeURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getOfficialDataTypeURIResponse(struct soap *soap, struct ns2__getOfficialDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getOfficialDataTypeURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const struct ns2__getOfficialDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getOfficialDataTypeURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const struct ns2__getOfficialDataTypeURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse);
  if (soap_out_ns2__getOfficialDataTypeURIResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getOfficialDataTypeURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getOfficialDataTypeURIReturn", -1, &a->_getOfficialDataTypeURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC4 soap_get_ns2__getOfficialDataTypeURIResponse(struct soap *soap, struct ns2__getOfficialDataTypeURIResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getOfficialDataTypeURIResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC4 soap_in_ns2__getOfficialDataTypeURIResponse(struct soap *soap, const char *tag, struct ns2__getOfficialDataTypeURIResponse *a, const char *type)
  {
    size_t soap_flag__getOfficialDataTypeURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getOfficialDataTypeURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse, sizeof(struct ns2__getOfficialDataTypeURIResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getOfficialDataTypeURIResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getOfficialDataTypeURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getOfficialDataTypeURIReturn, "xsd:string"))
                {
                  soap_flag__getOfficialDataTypeURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getOfficialDataTypeURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse, 0, sizeof(struct ns2__getOfficialDataTypeURIResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getOfficialDataTypeURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC6 soap_new_ns2__getOfficialDataTypeURIResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getOfficialDataTypeURIResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getOfficialDataTypeURIResponse(struct soap *soap, struct ns2__getOfficialDataTypeURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getOfficialDataTypeURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getOfficialDataTypeURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOfficialDataTypeURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getOfficialDataTypeURIResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getOfficialDataTypeURIResponse;
        if (size)
          *size = sizeof(struct ns2__getOfficialDataTypeURIResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getOfficialDataTypeURIResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getOfficialDataTypeURIResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getOfficialDataTypeURIResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getOfficialDataTypeURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getOfficialDataTypeURIResponse %p -> %p\n", q, p));
  *(struct ns2__getOfficialDataTypeURIResponse*)p = *(struct ns2__getOfficialDataTypeURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getOfficialURI(struct soap *soap, struct ns2__getOfficialURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getOfficialURI(struct soap *soap, const struct ns2__getOfficialURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getOfficialURI(struct soap *soap, const struct ns2__getOfficialURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getOfficialURI);
  if (soap_out_ns2__getOfficialURI(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOfficialURI(struct soap *soap, const char *tag, int id, const struct ns2__getOfficialURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOfficialURI), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getOfficialURI * SOAP_FMAC4 soap_get_ns2__getOfficialURI(struct soap *soap, struct ns2__getOfficialURI *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getOfficialURI(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getOfficialURI * SOAP_FMAC4 soap_in_ns2__getOfficialURI(struct soap *soap, const char *tag, struct ns2__getOfficialURI *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getOfficialURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOfficialURI, sizeof(struct ns2__getOfficialURI), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getOfficialURI(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getOfficialURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOfficialURI, 0, sizeof(struct ns2__getOfficialURI), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getOfficialURI * SOAP_FMAC6 soap_new_ns2__getOfficialURI(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getOfficialURI(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getOfficialURI(struct soap *soap, struct ns2__getOfficialURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getOfficialURI * SOAP_FMAC4 soap_instantiate_ns2__getOfficialURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOfficialURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getOfficialURI, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getOfficialURI;
        if (size)
          *size = sizeof(struct ns2__getOfficialURI);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getOfficialURI[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getOfficialURI);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getOfficialURI*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getOfficialURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getOfficialURI %p -> %p\n", q, p));
  *(struct ns2__getOfficialURI*)p = *(struct ns2__getOfficialURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getOfficialURIResponse(struct soap *soap, struct ns2__getOfficialURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getOfficialURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getOfficialURIResponse(struct soap *soap, const struct ns2__getOfficialURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getOfficialURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getOfficialURIResponse(struct soap *soap, const struct ns2__getOfficialURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getOfficialURIResponse);
  if (soap_out_ns2__getOfficialURIResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getOfficialURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getOfficialURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getOfficialURIResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getOfficialURIReturn", -1, &a->_getOfficialURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getOfficialURIResponse * SOAP_FMAC4 soap_get_ns2__getOfficialURIResponse(struct soap *soap, struct ns2__getOfficialURIResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getOfficialURIResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getOfficialURIResponse * SOAP_FMAC4 soap_in_ns2__getOfficialURIResponse(struct soap *soap, const char *tag, struct ns2__getOfficialURIResponse *a, const char *type)
  {
    size_t soap_flag__getOfficialURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getOfficialURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getOfficialURIResponse, sizeof(struct ns2__getOfficialURIResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getOfficialURIResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getOfficialURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getOfficialURIReturn, "xsd:string"))
                {
                  soap_flag__getOfficialURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getOfficialURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getOfficialURIResponse, 0, sizeof(struct ns2__getOfficialURIResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getOfficialURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getOfficialURIResponse * SOAP_FMAC6 soap_new_ns2__getOfficialURIResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getOfficialURIResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getOfficialURIResponse(struct soap *soap, struct ns2__getOfficialURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getOfficialURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getOfficialURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getOfficialURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getOfficialURIResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getOfficialURIResponse;
        if (size)
          *size = sizeof(struct ns2__getOfficialURIResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getOfficialURIResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getOfficialURIResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getOfficialURIResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getOfficialURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getOfficialURIResponse %p -> %p\n", q, p));
  *(struct ns2__getOfficialURIResponse*)p = *(struct ns2__getOfficialURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__isDeprecated(struct soap *soap, struct ns2__isDeprecated *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__isDeprecated(struct soap *soap, const struct ns2__isDeprecated *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__isDeprecated(struct soap *soap, const struct ns2__isDeprecated *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__isDeprecated);
  if (soap_out_ns2__isDeprecated(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__isDeprecated(struct soap *soap, const char *tag, int id, const struct ns2__isDeprecated *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__isDeprecated), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__isDeprecated * SOAP_FMAC4 soap_get_ns2__isDeprecated(struct soap *soap, struct ns2__isDeprecated *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__isDeprecated(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__isDeprecated * SOAP_FMAC4 soap_in_ns2__isDeprecated(struct soap *soap, const char *tag, struct ns2__isDeprecated *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__isDeprecated *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__isDeprecated, sizeof(struct ns2__isDeprecated), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__isDeprecated(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__isDeprecated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__isDeprecated, 0, sizeof(struct ns2__isDeprecated), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__isDeprecated * SOAP_FMAC6 soap_new_ns2__isDeprecated(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__isDeprecated(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__isDeprecated(struct soap *soap, struct ns2__isDeprecated *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__isDeprecated * SOAP_FMAC4 soap_instantiate_ns2__isDeprecated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__isDeprecated(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__isDeprecated, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__isDeprecated;
        if (size)
          *size = sizeof(struct ns2__isDeprecated);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__isDeprecated[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__isDeprecated);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__isDeprecated*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__isDeprecated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__isDeprecated %p -> %p\n", q, p));
  *(struct ns2__isDeprecated*)p = *(struct ns2__isDeprecated*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__isDeprecatedResponse(struct soap *soap, struct ns2__isDeprecatedResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_isDeprecatedReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__isDeprecatedResponse(struct soap *soap, const struct ns2__isDeprecatedResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_isDeprecatedReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__isDeprecatedResponse(struct soap *soap, const struct ns2__isDeprecatedResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__isDeprecatedResponse);
  if (soap_out_ns2__isDeprecatedResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__isDeprecatedResponse(struct soap *soap, const char *tag, int id, const struct ns2__isDeprecatedResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__isDeprecatedResponse), type))
    return soap->error;
  if (soap_out_string(soap, "isDeprecatedReturn", -1, &a->_isDeprecatedReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__isDeprecatedResponse * SOAP_FMAC4 soap_get_ns2__isDeprecatedResponse(struct soap *soap, struct ns2__isDeprecatedResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__isDeprecatedResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__isDeprecatedResponse * SOAP_FMAC4 soap_in_ns2__isDeprecatedResponse(struct soap *soap, const char *tag, struct ns2__isDeprecatedResponse *a, const char *type)
  {
    size_t soap_flag__isDeprecatedReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__isDeprecatedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__isDeprecatedResponse, sizeof(struct ns2__isDeprecatedResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__isDeprecatedResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__isDeprecatedReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_isDeprecatedReturn, "xsd:string"))
                {
                  soap_flag__isDeprecatedReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__isDeprecatedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__isDeprecatedResponse, 0, sizeof(struct ns2__isDeprecatedResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__isDeprecatedReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__isDeprecatedResponse * SOAP_FMAC6 soap_new_ns2__isDeprecatedResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__isDeprecatedResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__isDeprecatedResponse(struct soap *soap, struct ns2__isDeprecatedResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__isDeprecatedResponse * SOAP_FMAC4 soap_instantiate_ns2__isDeprecatedResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__isDeprecatedResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__isDeprecatedResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__isDeprecatedResponse;
        if (size)
          *size = sizeof(struct ns2__isDeprecatedResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__isDeprecatedResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__isDeprecatedResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__isDeprecatedResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__isDeprecatedResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__isDeprecatedResponse %p -> %p\n", q, p));
  *(struct ns2__isDeprecatedResponse*)p = *(struct ns2__isDeprecatedResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataResources(struct soap *soap, struct ns2__getDataResources *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataResources(struct soap *soap, const struct ns2__getDataResources *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataResources(struct soap *soap, const struct ns2__getDataResources *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataResources);
  if (soap_out_ns2__getDataResources(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataResources(struct soap *soap, const char *tag, int id, const struct ns2__getDataResources *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataResources), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataResources * SOAP_FMAC4 soap_get_ns2__getDataResources(struct soap *soap, struct ns2__getDataResources *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataResources(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataResources * SOAP_FMAC4 soap_in_ns2__getDataResources(struct soap *soap, const char *tag, struct ns2__getDataResources *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataResources *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataResources, sizeof(struct ns2__getDataResources), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataResources(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataResources *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataResources, 0, sizeof(struct ns2__getDataResources), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataResources * SOAP_FMAC6 soap_new_ns2__getDataResources(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataResources(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataResources(struct soap *soap, struct ns2__getDataResources *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataResources * SOAP_FMAC4 soap_instantiate_ns2__getDataResources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataResources(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataResources, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataResources;
        if (size)
          *size = sizeof(struct ns2__getDataResources);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataResources[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataResources);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataResources*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataResources(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataResources %p -> %p\n", q, p));
  *(struct ns2__getDataResources*)p = *(struct ns2__getDataResources*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataResourcesResponse(struct soap *soap, struct ns2__getDataResourcesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataResourcesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataResourcesResponse(struct soap *soap, const struct ns2__getDataResourcesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataResourcesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataResourcesResponse(struct soap *soap, const struct ns2__getDataResourcesResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataResourcesResponse);
  if (soap_out_ns2__getDataResourcesResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataResourcesResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataResourcesResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataResourcesResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataResourcesReturn", -1, &a->_getDataResourcesReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataResourcesResponse * SOAP_FMAC4 soap_get_ns2__getDataResourcesResponse(struct soap *soap, struct ns2__getDataResourcesResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataResourcesResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataResourcesResponse * SOAP_FMAC4 soap_in_ns2__getDataResourcesResponse(struct soap *soap, const char *tag, struct ns2__getDataResourcesResponse *a, const char *type)
  {
    size_t soap_flag__getDataResourcesReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataResourcesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataResourcesResponse, sizeof(struct ns2__getDataResourcesResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataResourcesResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataResourcesReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataResourcesReturn, "xsd:string"))
                {
                  soap_flag__getDataResourcesReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataResourcesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataResourcesResponse, 0, sizeof(struct ns2__getDataResourcesResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataResourcesResponse * SOAP_FMAC6 soap_new_ns2__getDataResourcesResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataResourcesResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataResourcesResponse(struct soap *soap, struct ns2__getDataResourcesResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataResourcesResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataResourcesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataResourcesResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataResourcesResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataResourcesResponse;
        if (size)
          *size = sizeof(struct ns2__getDataResourcesResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataResourcesResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataResourcesResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataResourcesResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataResourcesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataResourcesResponse %p -> %p\n", q, p));
  *(struct ns2__getDataResourcesResponse*)p = *(struct ns2__getDataResourcesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataEntry(struct soap *soap, struct ns2__getDataEntry *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
  soap_default_string(soap, &a->_resource);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataEntry(struct soap *soap, const struct ns2__getDataEntry *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
  soap_serialize_string(soap, &a->_resource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataEntry(struct soap *soap, const struct ns2__getDataEntry *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataEntry);
  if (soap_out_ns2__getDataEntry(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataEntry(struct soap *soap, const char *tag, int id, const struct ns2__getDataEntry *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataEntry), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  if (soap_out_string(soap, "resource", -1, &a->_resource, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataEntry * SOAP_FMAC4 soap_get_ns2__getDataEntry(struct soap *soap, struct ns2__getDataEntry *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataEntry(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataEntry * SOAP_FMAC4 soap_in_ns2__getDataEntry(struct soap *soap, const char *tag, struct ns2__getDataEntry *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    size_t soap_flag__resource = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataEntry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataEntry, sizeof(struct ns2__getDataEntry), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataEntry(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap_flag__resource && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_resource, "xsd:string"))
                {
                  soap_flag__resource--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataEntry, 0, sizeof(struct ns2__getDataEntry), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataEntry * SOAP_FMAC6 soap_new_ns2__getDataEntry(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataEntry(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataEntry(struct soap *soap, struct ns2__getDataEntry *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataEntry * SOAP_FMAC4 soap_instantiate_ns2__getDataEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataEntry(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataEntry, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataEntry;
        if (size)
          *size = sizeof(struct ns2__getDataEntry);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataEntry[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataEntry);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataEntry*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataEntry %p -> %p\n", q, p));
  *(struct ns2__getDataEntry*)p = *(struct ns2__getDataEntry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataEntryResponse(struct soap *soap, struct ns2__getDataEntryResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataEntryReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataEntryResponse(struct soap *soap, const struct ns2__getDataEntryResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataEntryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataEntryResponse(struct soap *soap, const struct ns2__getDataEntryResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataEntryResponse);
  if (soap_out_ns2__getDataEntryResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataEntryResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataEntryResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataEntryResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getDataEntryReturn", -1, &a->_getDataEntryReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataEntryResponse * SOAP_FMAC4 soap_get_ns2__getDataEntryResponse(struct soap *soap, struct ns2__getDataEntryResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataEntryResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataEntryResponse * SOAP_FMAC4 soap_in_ns2__getDataEntryResponse(struct soap *soap, const char *tag, struct ns2__getDataEntryResponse *a, const char *type)
  {
    size_t soap_flag__getDataEntryReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataEntryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataEntryResponse, sizeof(struct ns2__getDataEntryResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataEntryResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataEntryReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataEntryReturn, "xsd:string"))
                {
                  soap_flag__getDataEntryReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataEntryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataEntryResponse, 0, sizeof(struct ns2__getDataEntryResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataEntryReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataEntryResponse * SOAP_FMAC6 soap_new_ns2__getDataEntryResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataEntryResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataEntryResponse(struct soap *soap, struct ns2__getDataEntryResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataEntryResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataEntryResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataEntryResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataEntryResponse;
        if (size)
          *size = sizeof(struct ns2__getDataEntryResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataEntryResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataEntryResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataEntryResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataEntryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataEntryResponse %p -> %p\n", q, p));
  *(struct ns2__getDataEntryResponse*)p = *(struct ns2__getDataEntryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocations_(struct soap *soap, struct ns2__getLocations_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocations_(struct soap *soap, const struct ns2__getLocations_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocations_(struct soap *soap, const struct ns2__getLocations_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocations_);
  if (soap_out_ns2__getLocations_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocations_(struct soap *soap, const char *tag, int id, const struct ns2__getLocations_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocations_), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocations_ * SOAP_FMAC4 soap_get_ns2__getLocations_(struct soap *soap, struct ns2__getLocations_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getLocations_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getLocations_ * SOAP_FMAC4 soap_in_ns2__getLocations_(struct soap *soap, const char *tag, struct ns2__getLocations_ *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getLocations_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocations_, sizeof(struct ns2__getLocations_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getLocations_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getLocations_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocations_, 0, sizeof(struct ns2__getLocations_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getLocations_ * SOAP_FMAC6 soap_new_ns2__getLocations_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getLocations_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocations_(struct soap *soap, struct ns2__getLocations_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocations_ * SOAP_FMAC4 soap_instantiate_ns2__getLocations_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocations_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocations_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getLocations_;
        if (size)
          *size = sizeof(struct ns2__getLocations_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getLocations_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getLocations_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getLocations_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocations_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocations_ %p -> %p\n", q, p));
  *(struct ns2__getLocations_*)p = *(struct ns2__getLocations_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocationsResponse_(struct soap *soap, struct ns2__getLocationsResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getLocationsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocationsResponse_(struct soap *soap, const struct ns2__getLocationsResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getLocationsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocationsResponse_(struct soap *soap, const struct ns2__getLocationsResponse_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocationsResponse_);
  if (soap_out_ns2__getLocationsResponse_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocationsResponse_(struct soap *soap, const char *tag, int id, const struct ns2__getLocationsResponse_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocationsResponse_), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getLocationsReturn", -1, &a->_getLocationsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocationsResponse_ * SOAP_FMAC4 soap_get_ns2__getLocationsResponse_(struct soap *soap, struct ns2__getLocationsResponse_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getLocationsResponse_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getLocationsResponse_ * SOAP_FMAC4 soap_in_ns2__getLocationsResponse_(struct soap *soap, const char *tag, struct ns2__getLocationsResponse_ *a, const char *type)
  {
    size_t soap_flag__getLocationsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getLocationsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocationsResponse_, sizeof(struct ns2__getLocationsResponse_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getLocationsResponse_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getLocationsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getLocationsReturn, "xsd:string"))
                {
                  soap_flag__getLocationsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getLocationsResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocationsResponse_, 0, sizeof(struct ns2__getLocationsResponse_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getLocationsResponse_ * SOAP_FMAC6 soap_new_ns2__getLocationsResponse_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getLocationsResponse_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocationsResponse_(struct soap *soap, struct ns2__getLocationsResponse_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocationsResponse_ * SOAP_FMAC4 soap_instantiate_ns2__getLocationsResponse_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocationsResponse_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocationsResponse_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getLocationsResponse_;
        if (size)
          *size = sizeof(struct ns2__getLocationsResponse_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getLocationsResponse_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getLocationsResponse_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getLocationsResponse_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocationsResponse_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocationsResponse_ %p -> %p\n", q, p));
  *(struct ns2__getLocationsResponse_*)p = *(struct ns2__getLocationsResponse_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocations(struct soap *soap, struct ns2__getLocations *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocations(struct soap *soap, const struct ns2__getLocations *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocations(struct soap *soap, const struct ns2__getLocations *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocations);
  if (soap_out_ns2__getLocations(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocations(struct soap *soap, const char *tag, int id, const struct ns2__getLocations *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocations), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocations * SOAP_FMAC4 soap_get_ns2__getLocations(struct soap *soap, struct ns2__getLocations *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getLocations(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getLocations * SOAP_FMAC4 soap_in_ns2__getLocations(struct soap *soap, const char *tag, struct ns2__getLocations *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getLocations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocations, sizeof(struct ns2__getLocations), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getLocations(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getLocations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocations, 0, sizeof(struct ns2__getLocations), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getLocations * SOAP_FMAC6 soap_new_ns2__getLocations(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getLocations(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocations(struct soap *soap, struct ns2__getLocations *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocations * SOAP_FMAC4 soap_instantiate_ns2__getLocations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocations(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocations, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getLocations;
        if (size)
          *size = sizeof(struct ns2__getLocations);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getLocations[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getLocations);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getLocations*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocations %p -> %p\n", q, p));
  *(struct ns2__getLocations*)p = *(struct ns2__getLocations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocationsResponse(struct soap *soap, struct ns2__getLocationsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getLocationsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocationsResponse(struct soap *soap, const struct ns2__getLocationsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getLocationsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocationsResponse(struct soap *soap, const struct ns2__getLocationsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocationsResponse);
  if (soap_out_ns2__getLocationsResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocationsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getLocationsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocationsResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getLocationsReturn", -1, &a->_getLocationsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocationsResponse * SOAP_FMAC4 soap_get_ns2__getLocationsResponse(struct soap *soap, struct ns2__getLocationsResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getLocationsResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getLocationsResponse * SOAP_FMAC4 soap_in_ns2__getLocationsResponse(struct soap *soap, const char *tag, struct ns2__getLocationsResponse *a, const char *type)
  {
    size_t soap_flag__getLocationsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getLocationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocationsResponse, sizeof(struct ns2__getLocationsResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getLocationsResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getLocationsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getLocationsReturn, "xsd:string"))
                {
                  soap_flag__getLocationsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getLocationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocationsResponse, 0, sizeof(struct ns2__getLocationsResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getLocationsResponse * SOAP_FMAC6 soap_new_ns2__getLocationsResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getLocationsResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocationsResponse(struct soap *soap, struct ns2__getLocationsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocationsResponse * SOAP_FMAC4 soap_instantiate_ns2__getLocationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocationsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocationsResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getLocationsResponse;
        if (size)
          *size = sizeof(struct ns2__getLocationsResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getLocationsResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getLocationsResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getLocationsResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocationsResponse %p -> %p\n", q, p));
  *(struct ns2__getLocationsResponse*)p = *(struct ns2__getLocationsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataEntries_(struct soap *soap, struct ns2__getDataEntries_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataEntries_(struct soap *soap, const struct ns2__getDataEntries_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataEntries_(struct soap *soap, const struct ns2__getDataEntries_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataEntries_);
  if (soap_out_ns2__getDataEntries_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataEntries_(struct soap *soap, const char *tag, int id, const struct ns2__getDataEntries_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataEntries_), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataEntries_ * SOAP_FMAC4 soap_get_ns2__getDataEntries_(struct soap *soap, struct ns2__getDataEntries_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataEntries_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataEntries_ * SOAP_FMAC4 soap_in_ns2__getDataEntries_(struct soap *soap, const char *tag, struct ns2__getDataEntries_ *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataEntries_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataEntries_, sizeof(struct ns2__getDataEntries_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataEntries_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataEntries_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataEntries_, 0, sizeof(struct ns2__getDataEntries_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataEntries_ * SOAP_FMAC6 soap_new_ns2__getDataEntries_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataEntries_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataEntries_(struct soap *soap, struct ns2__getDataEntries_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataEntries_ * SOAP_FMAC4 soap_instantiate_ns2__getDataEntries_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataEntries_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataEntries_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataEntries_;
        if (size)
          *size = sizeof(struct ns2__getDataEntries_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataEntries_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataEntries_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataEntries_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataEntries_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataEntries_ %p -> %p\n", q, p));
  *(struct ns2__getDataEntries_*)p = *(struct ns2__getDataEntries_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataEntriesResponse_(struct soap *soap, struct ns2__getDataEntriesResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataEntriesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataEntriesResponse_(struct soap *soap, const struct ns2__getDataEntriesResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataEntriesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataEntriesResponse_(struct soap *soap, const struct ns2__getDataEntriesResponse_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataEntriesResponse_);
  if (soap_out_ns2__getDataEntriesResponse_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataEntriesResponse_(struct soap *soap, const char *tag, int id, const struct ns2__getDataEntriesResponse_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataEntriesResponse_), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataEntriesReturn", -1, &a->_getDataEntriesReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataEntriesResponse_ * SOAP_FMAC4 soap_get_ns2__getDataEntriesResponse_(struct soap *soap, struct ns2__getDataEntriesResponse_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataEntriesResponse_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataEntriesResponse_ * SOAP_FMAC4 soap_in_ns2__getDataEntriesResponse_(struct soap *soap, const char *tag, struct ns2__getDataEntriesResponse_ *a, const char *type)
  {
    size_t soap_flag__getDataEntriesReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataEntriesResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataEntriesResponse_, sizeof(struct ns2__getDataEntriesResponse_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataEntriesResponse_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataEntriesReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataEntriesReturn, "xsd:string"))
                {
                  soap_flag__getDataEntriesReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataEntriesResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataEntriesResponse_, 0, sizeof(struct ns2__getDataEntriesResponse_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataEntriesResponse_ * SOAP_FMAC6 soap_new_ns2__getDataEntriesResponse_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataEntriesResponse_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataEntriesResponse_(struct soap *soap, struct ns2__getDataEntriesResponse_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataEntriesResponse_ * SOAP_FMAC4 soap_instantiate_ns2__getDataEntriesResponse_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataEntriesResponse_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataEntriesResponse_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataEntriesResponse_;
        if (size)
          *size = sizeof(struct ns2__getDataEntriesResponse_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataEntriesResponse_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataEntriesResponse_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataEntriesResponse_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataEntriesResponse_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataEntriesResponse_ %p -> %p\n", q, p));
  *(struct ns2__getDataEntriesResponse_*)p = *(struct ns2__getDataEntriesResponse_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataEntries(struct soap *soap, struct ns2__getDataEntries *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataEntries(struct soap *soap, const struct ns2__getDataEntries *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataEntries(struct soap *soap, const struct ns2__getDataEntries *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataEntries);
  if (soap_out_ns2__getDataEntries(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataEntries(struct soap *soap, const char *tag, int id, const struct ns2__getDataEntries *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataEntries), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataEntries * SOAP_FMAC4 soap_get_ns2__getDataEntries(struct soap *soap, struct ns2__getDataEntries *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataEntries(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataEntries * SOAP_FMAC4 soap_in_ns2__getDataEntries(struct soap *soap, const char *tag, struct ns2__getDataEntries *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataEntries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataEntries, sizeof(struct ns2__getDataEntries), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataEntries(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataEntries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataEntries, 0, sizeof(struct ns2__getDataEntries), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataEntries * SOAP_FMAC6 soap_new_ns2__getDataEntries(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataEntries(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataEntries(struct soap *soap, struct ns2__getDataEntries *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataEntries * SOAP_FMAC4 soap_instantiate_ns2__getDataEntries(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataEntries(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataEntries, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataEntries;
        if (size)
          *size = sizeof(struct ns2__getDataEntries);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataEntries[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataEntries);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataEntries*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataEntries(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataEntries %p -> %p\n", q, p));
  *(struct ns2__getDataEntries*)p = *(struct ns2__getDataEntries*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataEntriesResponse(struct soap *soap, struct ns2__getDataEntriesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataEntriesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataEntriesResponse(struct soap *soap, const struct ns2__getDataEntriesResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataEntriesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataEntriesResponse(struct soap *soap, const struct ns2__getDataEntriesResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataEntriesResponse);
  if (soap_out_ns2__getDataEntriesResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataEntriesResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataEntriesResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataEntriesResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataEntriesReturn", -1, &a->_getDataEntriesReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataEntriesResponse * SOAP_FMAC4 soap_get_ns2__getDataEntriesResponse(struct soap *soap, struct ns2__getDataEntriesResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataEntriesResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataEntriesResponse * SOAP_FMAC4 soap_in_ns2__getDataEntriesResponse(struct soap *soap, const char *tag, struct ns2__getDataEntriesResponse *a, const char *type)
  {
    size_t soap_flag__getDataEntriesReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataEntriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataEntriesResponse, sizeof(struct ns2__getDataEntriesResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataEntriesResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataEntriesReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataEntriesReturn, "xsd:string"))
                {
                  soap_flag__getDataEntriesReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataEntriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataEntriesResponse, 0, sizeof(struct ns2__getDataEntriesResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataEntriesResponse * SOAP_FMAC6 soap_new_ns2__getDataEntriesResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataEntriesResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataEntriesResponse(struct soap *soap, struct ns2__getDataEntriesResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataEntriesResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataEntriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataEntriesResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataEntriesResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataEntriesResponse;
        if (size)
          *size = sizeof(struct ns2__getDataEntriesResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataEntriesResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataEntriesResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataEntriesResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataEntriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataEntriesResponse %p -> %p\n", q, p));
  *(struct ns2__getDataEntriesResponse*)p = *(struct ns2__getDataEntriesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeDef(struct soap *soap, struct ns2__getDataTypeDef *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_nickname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeDef(struct soap *soap, const struct ns2__getDataTypeDef *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_nickname);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeDef(struct soap *soap, const struct ns2__getDataTypeDef *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeDef);
  if (soap_out_ns2__getDataTypeDef(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeDef(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeDef *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeDef), type))
    return soap->error;
  if (soap_out_string(soap, "nickname", -1, &a->_nickname, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeDef * SOAP_FMAC4 soap_get_ns2__getDataTypeDef(struct soap *soap, struct ns2__getDataTypeDef *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeDef(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeDef * SOAP_FMAC4 soap_in_ns2__getDataTypeDef(struct soap *soap, const char *tag, struct ns2__getDataTypeDef *a, const char *type)
  {
    size_t soap_flag__nickname = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeDef *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeDef, sizeof(struct ns2__getDataTypeDef), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeDef(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__nickname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_nickname, "xsd:string"))
                {
                  soap_flag__nickname--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeDef, 0, sizeof(struct ns2__getDataTypeDef), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeDef * SOAP_FMAC6 soap_new_ns2__getDataTypeDef(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeDef(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeDef(struct soap *soap, struct ns2__getDataTypeDef *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeDef * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeDef(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeDef, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeDef;
        if (size)
          *size = sizeof(struct ns2__getDataTypeDef);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeDef[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeDef);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeDef*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeDef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeDef %p -> %p\n", q, p));
  *(struct ns2__getDataTypeDef*)p = *(struct ns2__getDataTypeDef*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeDefResponse(struct soap *soap, struct ns2__getDataTypeDefResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataTypeDefReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeDefResponse(struct soap *soap, const struct ns2__getDataTypeDefResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataTypeDefReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeDefResponse(struct soap *soap, const struct ns2__getDataTypeDefResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeDefResponse);
  if (soap_out_ns2__getDataTypeDefResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeDefResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeDefResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeDefResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getDataTypeDefReturn", -1, &a->_getDataTypeDefReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeDefResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeDefResponse(struct soap *soap, struct ns2__getDataTypeDefResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeDefResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeDefResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeDefResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeDefResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeDefReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeDefResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeDefResponse, sizeof(struct ns2__getDataTypeDefResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeDefResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeDefReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataTypeDefReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeDefReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeDefResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeDefResponse, 0, sizeof(struct ns2__getDataTypeDefResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeDefReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeDefResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeDefResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeDefResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeDefResponse(struct soap *soap, struct ns2__getDataTypeDefResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeDefResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeDefResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeDefResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeDefResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeDefResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeDefResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeDefResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeDefResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeDefResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeDefResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeDefResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeDefResponse*)p = *(struct ns2__getDataTypeDefResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURN(struct soap *soap, struct ns2__getURN *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURN(struct soap *soap, const struct ns2__getURN *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURN(struct soap *soap, const struct ns2__getURN *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURN);
  if (soap_out_ns2__getURN(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURN(struct soap *soap, const char *tag, int id, const struct ns2__getURN *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURN), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURN * SOAP_FMAC4 soap_get_ns2__getURN(struct soap *soap, struct ns2__getURN *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURN(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURN * SOAP_FMAC4 soap_in_ns2__getURN(struct soap *soap, const char *tag, struct ns2__getURN *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURN, sizeof(struct ns2__getURN), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURN(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURN, 0, sizeof(struct ns2__getURN), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURN * SOAP_FMAC6 soap_new_ns2__getURN(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURN(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURN(struct soap *soap, struct ns2__getURN *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURN * SOAP_FMAC4 soap_instantiate_ns2__getURN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURN(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURN, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURN;
        if (size)
          *size = sizeof(struct ns2__getURN);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURN[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURN);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURN*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURN(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURN %p -> %p\n", q, p));
  *(struct ns2__getURN*)p = *(struct ns2__getURN*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURNResponse(struct soap *soap, struct ns2__getURNResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getURNReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURNResponse(struct soap *soap, const struct ns2__getURNResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getURNReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURNResponse(struct soap *soap, const struct ns2__getURNResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURNResponse);
  if (soap_out_ns2__getURNResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURNResponse(struct soap *soap, const char *tag, int id, const struct ns2__getURNResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURNResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getURNReturn", -1, &a->_getURNReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURNResponse * SOAP_FMAC4 soap_get_ns2__getURNResponse(struct soap *soap, struct ns2__getURNResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURNResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURNResponse * SOAP_FMAC4 soap_in_ns2__getURNResponse(struct soap *soap, const char *tag, struct ns2__getURNResponse *a, const char *type)
  {
    size_t soap_flag__getURNReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURNResponse, sizeof(struct ns2__getURNResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURNResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getURNReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getURNReturn, "xsd:string"))
                {
                  soap_flag__getURNReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURNResponse, 0, sizeof(struct ns2__getURNResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getURNReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURNResponse * SOAP_FMAC6 soap_new_ns2__getURNResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURNResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURNResponse(struct soap *soap, struct ns2__getURNResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURNResponse * SOAP_FMAC4 soap_instantiate_ns2__getURNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURNResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURNResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURNResponse;
        if (size)
          *size = sizeof(struct ns2__getURNResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURNResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURNResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURNResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURNResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURNResponse %p -> %p\n", q, p));
  *(struct ns2__getURNResponse*)p = *(struct ns2__getURNResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeAllURIs(struct soap *soap, struct ns2__getDataTypeAllURIs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeAllURIs(struct soap *soap, const struct ns2__getDataTypeAllURIs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeAllURIs(struct soap *soap, const struct ns2__getDataTypeAllURIs *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeAllURIs);
  if (soap_out_ns2__getDataTypeAllURIs(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeAllURIs(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeAllURIs *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeAllURIs), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeAllURIs * SOAP_FMAC4 soap_get_ns2__getDataTypeAllURIs(struct soap *soap, struct ns2__getDataTypeAllURIs *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeAllURIs(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeAllURIs * SOAP_FMAC4 soap_in_ns2__getDataTypeAllURIs(struct soap *soap, const char *tag, struct ns2__getDataTypeAllURIs *a, const char *type)
  {
    size_t soap_flag__name = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeAllURIs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeAllURIs, sizeof(struct ns2__getDataTypeAllURIs), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeAllURIs(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeAllURIs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeAllURIs, 0, sizeof(struct ns2__getDataTypeAllURIs), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeAllURIs * SOAP_FMAC6 soap_new_ns2__getDataTypeAllURIs(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeAllURIs(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeAllURIs(struct soap *soap, struct ns2__getDataTypeAllURIs *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeAllURIs * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeAllURIs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeAllURIs(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeAllURIs, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeAllURIs;
        if (size)
          *size = sizeof(struct ns2__getDataTypeAllURIs);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeAllURIs[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeAllURIs);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeAllURIs*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeAllURIs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeAllURIs %p -> %p\n", q, p));
  *(struct ns2__getDataTypeAllURIs*)p = *(struct ns2__getDataTypeAllURIs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeAllURIsResponse(struct soap *soap, struct ns2__getDataTypeAllURIsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeAllURIsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeAllURIsResponse(struct soap *soap, const struct ns2__getDataTypeAllURIsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeAllURIsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeAllURIsResponse(struct soap *soap, const struct ns2__getDataTypeAllURIsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeAllURIsResponse);
  if (soap_out_ns2__getDataTypeAllURIsResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeAllURIsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeAllURIsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeAllURIsResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeAllURIsReturn", -1, &a->_getDataTypeAllURIsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeAllURIsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeAllURIsResponse(struct soap *soap, struct ns2__getDataTypeAllURIsResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeAllURIsResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeAllURIsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeAllURIsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeAllURIsResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeAllURIsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeAllURIsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeAllURIsResponse, sizeof(struct ns2__getDataTypeAllURIsResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeAllURIsResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeAllURIsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeAllURIsReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeAllURIsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeAllURIsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeAllURIsResponse, 0, sizeof(struct ns2__getDataTypeAllURIsResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeAllURIsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeAllURIsResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeAllURIsResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeAllURIsResponse(struct soap *soap, struct ns2__getDataTypeAllURIsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeAllURIsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeAllURIsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeAllURIsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeAllURIsResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeAllURIsResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeAllURIsResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeAllURIsResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeAllURIsResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeAllURIsResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeAllURIsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeAllURIsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeAllURIsResponse*)p = *(struct ns2__getDataTypeAllURIsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIs_(struct soap *soap, struct ns2__getDataTypeURIs_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIs_(struct soap *soap, const struct ns2__getDataTypeURIs_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIs_(struct soap *soap, const struct ns2__getDataTypeURIs_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIs_);
  if (soap_out_ns2__getDataTypeURIs_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIs_(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIs_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIs_), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "type", -1, &a->_type, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIs_ * SOAP_FMAC4 soap_get_ns2__getDataTypeURIs_(struct soap *soap, struct ns2__getDataTypeURIs_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURIs_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURIs_ * SOAP_FMAC4 soap_in_ns2__getDataTypeURIs_(struct soap *soap, const char *tag, struct ns2__getDataTypeURIs_ *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__type = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURIs_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIs_, sizeof(struct ns2__getDataTypeURIs_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURIs_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
                {
                  soap_flag__type--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURIs_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIs_, 0, sizeof(struct ns2__getDataTypeURIs_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURIs_ * SOAP_FMAC6 soap_new_ns2__getDataTypeURIs_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURIs_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIs_(struct soap *soap, struct ns2__getDataTypeURIs_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIs_ * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIs_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIs_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIs_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIs_;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURIs_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIs_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURIs_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURIs_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIs_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIs_ %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIs_*)p = *(struct ns2__getDataTypeURIs_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIsResponse_(struct soap *soap, struct ns2__getDataTypeURIsResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeURIsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIsResponse_(struct soap *soap, const struct ns2__getDataTypeURIsResponse_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeURIsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIsResponse_(struct soap *soap, const struct ns2__getDataTypeURIsResponse_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIsResponse_);
  if (soap_out_ns2__getDataTypeURIsResponse_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIsResponse_(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIsResponse_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIsResponse_), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeURIsReturn", -1, &a->_getDataTypeURIsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse_ * SOAP_FMAC4 soap_get_ns2__getDataTypeURIsResponse_(struct soap *soap, struct ns2__getDataTypeURIsResponse_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURIsResponse_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse_ * SOAP_FMAC4 soap_in_ns2__getDataTypeURIsResponse_(struct soap *soap, const char *tag, struct ns2__getDataTypeURIsResponse_ *a, const char *type)
  {
    size_t soap_flag__getDataTypeURIsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURIsResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIsResponse_, sizeof(struct ns2__getDataTypeURIsResponse_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURIsResponse_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURIsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeURIsReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURIsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURIsResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIsResponse_, 0, sizeof(struct ns2__getDataTypeURIsResponse_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURIsResponse_ * SOAP_FMAC6 soap_new_ns2__getDataTypeURIsResponse_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURIsResponse_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIsResponse_(struct soap *soap, struct ns2__getDataTypeURIsResponse_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse_ * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIsResponse_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIsResponse_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIsResponse_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIsResponse_;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURIsResponse_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIsResponse_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURIsResponse_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURIsResponse_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIsResponse_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIsResponse_ %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIsResponse_*)p = *(struct ns2__getDataTypeURIsResponse_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIs(struct soap *soap, struct ns2__getDataTypeURIs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIs(struct soap *soap, const struct ns2__getDataTypeURIs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIs(struct soap *soap, const struct ns2__getDataTypeURIs *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIs);
  if (soap_out_ns2__getDataTypeURIs(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIs(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIs *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIs), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "type", -1, &a->_type, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIs * SOAP_FMAC4 soap_get_ns2__getDataTypeURIs(struct soap *soap, struct ns2__getDataTypeURIs *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURIs(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURIs * SOAP_FMAC4 soap_in_ns2__getDataTypeURIs(struct soap *soap, const char *tag, struct ns2__getDataTypeURIs *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__type = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURIs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIs, sizeof(struct ns2__getDataTypeURIs), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURIs(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
                {
                  soap_flag__type--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURIs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIs, 0, sizeof(struct ns2__getDataTypeURIs), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURIs * SOAP_FMAC6 soap_new_ns2__getDataTypeURIs(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURIs(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIs(struct soap *soap, struct ns2__getDataTypeURIs *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIs * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIs(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIs, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIs;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURIs);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIs[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURIs);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURIs*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIs %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIs*)p = *(struct ns2__getDataTypeURIs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIsResponse(struct soap *soap, struct ns2__getDataTypeURIsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeURIsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIsResponse(struct soap *soap, const struct ns2__getDataTypeURIsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeURIsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIsResponse(struct soap *soap, const struct ns2__getDataTypeURIsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIsResponse);
  if (soap_out_ns2__getDataTypeURIsResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIsResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeURIsReturn", -1, &a->_getDataTypeURIsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURIsResponse(struct soap *soap, struct ns2__getDataTypeURIsResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURIsResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURIsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURIsResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeURIsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURIsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIsResponse, sizeof(struct ns2__getDataTypeURIsResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURIsResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURIsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeURIsReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURIsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURIsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIsResponse, 0, sizeof(struct ns2__getDataTypeURIsResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURIsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURIsResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURIsResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIsResponse(struct soap *soap, struct ns2__getDataTypeURIsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIsResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIsResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURIsResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIsResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURIsResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURIsResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIsResponse*)p = *(struct ns2__getDataTypeURIsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURI_(struct soap *soap, struct ns2__getDataTypeURI_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURI_(struct soap *soap, const struct ns2__getDataTypeURI_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURI_(struct soap *soap, const struct ns2__getDataTypeURI_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURI_);
  if (soap_out_ns2__getDataTypeURI_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURI_(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURI_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURI_), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "type", -1, &a->_type, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURI_ * SOAP_FMAC4 soap_get_ns2__getDataTypeURI_(struct soap *soap, struct ns2__getDataTypeURI_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURI_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURI_ * SOAP_FMAC4 soap_in_ns2__getDataTypeURI_(struct soap *soap, const char *tag, struct ns2__getDataTypeURI_ *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__type = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURI_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURI_, sizeof(struct ns2__getDataTypeURI_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURI_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
                {
                  soap_flag__type--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURI_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURI_, 0, sizeof(struct ns2__getDataTypeURI_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURI_ * SOAP_FMAC6 soap_new_ns2__getDataTypeURI_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURI_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURI_(struct soap *soap, struct ns2__getDataTypeURI_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURI_ * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURI_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURI_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURI_;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURI_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURI_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURI_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURI_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURI_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURI_ %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURI_*)p = *(struct ns2__getDataTypeURI_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURI_Response(struct soap *soap, struct ns2__getDataTypeURI_Response *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataTypeURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURI_Response(struct soap *soap, const struct ns2__getDataTypeURI_Response *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataTypeURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURI_Response(struct soap *soap, const struct ns2__getDataTypeURI_Response *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURI_Response);
  if (soap_out_ns2__getDataTypeURI_Response(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURI_Response(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURI_Response *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURI_Response), type))
    return soap->error;
  if (soap_out_string(soap, "getDataTypeURIReturn", -1, &a->_getDataTypeURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURI_Response * SOAP_FMAC4 soap_get_ns2__getDataTypeURI_Response(struct soap *soap, struct ns2__getDataTypeURI_Response *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURI_Response(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURI_Response * SOAP_FMAC4 soap_in_ns2__getDataTypeURI_Response(struct soap *soap, const char *tag, struct ns2__getDataTypeURI_Response *a, const char *type)
  {
    size_t soap_flag__getDataTypeURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURI_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURI_Response, sizeof(struct ns2__getDataTypeURI_Response), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURI_Response(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataTypeURIReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURI_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURI_Response, 0, sizeof(struct ns2__getDataTypeURI_Response), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURI_Response * SOAP_FMAC6 soap_new_ns2__getDataTypeURI_Response(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURI_Response(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURI_Response(struct soap *soap, struct ns2__getDataTypeURI_Response *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURI_Response * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURI_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURI_Response(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURI_Response, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURI_Response;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURI_Response);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURI_Response[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURI_Response);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURI_Response*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURI_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURI_Response %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURI_Response*)p = *(struct ns2__getDataTypeURI_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURI(struct soap *soap, struct ns2__getDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURI(struct soap *soap, const struct ns2__getDataTypeURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURI(struct soap *soap, const struct ns2__getDataTypeURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURI);
  if (soap_out_ns2__getDataTypeURI(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURI(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURI), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "type", -1, &a->_type, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURI * SOAP_FMAC4 soap_get_ns2__getDataTypeURI(struct soap *soap, struct ns2__getDataTypeURI *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURI(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURI * SOAP_FMAC4 soap_in_ns2__getDataTypeURI(struct soap *soap, const char *tag, struct ns2__getDataTypeURI *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__type = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURI, sizeof(struct ns2__getDataTypeURI), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURI(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
                {
                  soap_flag__type--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURI, 0, sizeof(struct ns2__getDataTypeURI), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURI * SOAP_FMAC6 soap_new_ns2__getDataTypeURI(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURI(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURI(struct soap *soap, struct ns2__getDataTypeURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURI * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURI, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURI;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURI);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURI[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURI);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURI*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURI %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURI*)p = *(struct ns2__getDataTypeURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURIResponse(struct soap *soap, struct ns2__getDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataTypeURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURIResponse(struct soap *soap, const struct ns2__getDataTypeURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataTypeURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURIResponse(struct soap *soap, const struct ns2__getDataTypeURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURIResponse);
  if (soap_out_ns2__getDataTypeURIResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURIResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getDataTypeURIReturn", -1, &a->_getDataTypeURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURIResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURIResponse(struct soap *soap, struct ns2__getDataTypeURIResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURIResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURIResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURIResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURIResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURIResponse, sizeof(struct ns2__getDataTypeURIResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURIResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataTypeURIReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURIResponse, 0, sizeof(struct ns2__getDataTypeURIResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURIResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURIResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURIResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURIResponse(struct soap *soap, struct ns2__getDataTypeURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURIResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURIResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURIResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURIResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURIResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURIResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURIResponse*)p = *(struct ns2__getDataTypeURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURLs(struct soap *soap, struct ns2__getDataTypeURLs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURLs(struct soap *soap, const struct ns2__getDataTypeURLs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURLs(struct soap *soap, const struct ns2__getDataTypeURLs *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURLs);
  if (soap_out_ns2__getDataTypeURLs(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURLs(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURLs *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURLs), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURLs * SOAP_FMAC4 soap_get_ns2__getDataTypeURLs(struct soap *soap, struct ns2__getDataTypeURLs *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURLs(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURLs * SOAP_FMAC4 soap_in_ns2__getDataTypeURLs(struct soap *soap, const char *tag, struct ns2__getDataTypeURLs *a, const char *type)
  {
    size_t soap_flag__name = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURLs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURLs, sizeof(struct ns2__getDataTypeURLs), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURLs(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURLs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURLs, 0, sizeof(struct ns2__getDataTypeURLs), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURLs * SOAP_FMAC6 soap_new_ns2__getDataTypeURLs(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURLs(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURLs(struct soap *soap, struct ns2__getDataTypeURLs *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURLs * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURLs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURLs(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURLs, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURLs;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURLs);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURLs[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURLs);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURLs*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURLs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURLs %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURLs*)p = *(struct ns2__getDataTypeURLs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURLsResponse(struct soap *soap, struct ns2__getDataTypeURLsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeURLsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURLsResponse(struct soap *soap, const struct ns2__getDataTypeURLsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeURLsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURLsResponse(struct soap *soap, const struct ns2__getDataTypeURLsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURLsResponse);
  if (soap_out_ns2__getDataTypeURLsResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURLsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURLsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURLsResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeURLsReturn", -1, &a->_getDataTypeURLsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURLsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURLsResponse(struct soap *soap, struct ns2__getDataTypeURLsResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURLsResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURLsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURLsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURLsResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeURLsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURLsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURLsResponse, sizeof(struct ns2__getDataTypeURLsResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURLsResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURLsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeURLsReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURLsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURLsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURLsResponse, 0, sizeof(struct ns2__getDataTypeURLsResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURLsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURLsResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURLsResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURLsResponse(struct soap *soap, struct ns2__getDataTypeURLsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURLsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURLsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURLsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURLsResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURLsResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURLsResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURLsResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURLsResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURLsResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURLsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURLsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURLsResponse*)p = *(struct ns2__getDataTypeURLsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURL(struct soap *soap, struct ns2__getDataTypeURL *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURL(struct soap *soap, const struct ns2__getDataTypeURL *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURL(struct soap *soap, const struct ns2__getDataTypeURL *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURL);
  if (soap_out_ns2__getDataTypeURL(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURL(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURL *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURL), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURL * SOAP_FMAC4 soap_get_ns2__getDataTypeURL(struct soap *soap, struct ns2__getDataTypeURL *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURL(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURL * SOAP_FMAC4 soap_in_ns2__getDataTypeURL(struct soap *soap, const char *tag, struct ns2__getDataTypeURL *a, const char *type)
  {
    size_t soap_flag__name = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURL, sizeof(struct ns2__getDataTypeURL), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURL(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURL, 0, sizeof(struct ns2__getDataTypeURL), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURL * SOAP_FMAC6 soap_new_ns2__getDataTypeURL(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURL(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURL(struct soap *soap, struct ns2__getDataTypeURL *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURL * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURL(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURL, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURL;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURL);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURL[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURL);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURL*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURL %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURL*)p = *(struct ns2__getDataTypeURL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURLResponse(struct soap *soap, struct ns2__getDataTypeURLResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataTypeURLReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURLResponse(struct soap *soap, const struct ns2__getDataTypeURLResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataTypeURLReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURLResponse(struct soap *soap, const struct ns2__getDataTypeURLResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURLResponse);
  if (soap_out_ns2__getDataTypeURLResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURLResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURLResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURLResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getDataTypeURLReturn", -1, &a->_getDataTypeURLReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURLResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURLResponse(struct soap *soap, struct ns2__getDataTypeURLResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURLResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURLResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURLResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURLResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeURLReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURLResponse, sizeof(struct ns2__getDataTypeURLResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURLResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURLReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataTypeURLReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURLReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURLResponse, 0, sizeof(struct ns2__getDataTypeURLResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeURLReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURLResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURLResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURLResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURLResponse(struct soap *soap, struct ns2__getDataTypeURLResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURLResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURLResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURLResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURLResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURLResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURLResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURLResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURLResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURLResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURLResponse*)p = *(struct ns2__getDataTypeURLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURNs(struct soap *soap, struct ns2__getDataTypeURNs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURNs(struct soap *soap, const struct ns2__getDataTypeURNs *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURNs(struct soap *soap, const struct ns2__getDataTypeURNs *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURNs);
  if (soap_out_ns2__getDataTypeURNs(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURNs(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURNs *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURNs), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURNs * SOAP_FMAC4 soap_get_ns2__getDataTypeURNs(struct soap *soap, struct ns2__getDataTypeURNs *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURNs(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURNs * SOAP_FMAC4 soap_in_ns2__getDataTypeURNs(struct soap *soap, const char *tag, struct ns2__getDataTypeURNs *a, const char *type)
  {
    size_t soap_flag__name = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURNs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURNs, sizeof(struct ns2__getDataTypeURNs), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURNs(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURNs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURNs, 0, sizeof(struct ns2__getDataTypeURNs), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURNs * SOAP_FMAC6 soap_new_ns2__getDataTypeURNs(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURNs(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURNs(struct soap *soap, struct ns2__getDataTypeURNs *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURNs * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURNs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURNs(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURNs, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURNs;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURNs);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURNs[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURNs);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURNs*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURNs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURNs %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURNs*)p = *(struct ns2__getDataTypeURNs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURNsResponse(struct soap *soap, struct ns2__getDataTypeURNsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  a->_getDataTypeURNsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURNsResponse(struct soap *soap, const struct ns2__getDataTypeURNsResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(soap, &a->_getDataTypeURNsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURNsResponse(struct soap *soap, const struct ns2__getDataTypeURNsResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURNsResponse);
  if (soap_out_ns2__getDataTypeURNsResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURNsResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURNsResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURNsResponse), type))
    return soap->error;
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, "getDataTypeURNsReturn", -1, &a->_getDataTypeURNsReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURNsResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURNsResponse(struct soap *soap, struct ns2__getDataTypeURNsResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURNsResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURNsResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURNsResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURNsResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeURNsReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURNsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURNsResponse, sizeof(struct ns2__getDataTypeURNsResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURNsResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURNsReturn && soap->error == SOAP_TAG_MISMATCH)
              if (soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, NULL, &a->_getDataTypeURNsReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURNsReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURNsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURNsResponse, 0, sizeof(struct ns2__getDataTypeURNsResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURNsResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURNsResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURNsResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURNsResponse(struct soap *soap, struct ns2__getDataTypeURNsResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURNsResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURNsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURNsResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURNsResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURNsResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURNsResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURNsResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURNsResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURNsResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURNsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURNsResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURNsResponse*)p = *(struct ns2__getDataTypeURNsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURN(struct soap *soap, struct ns2__getDataTypeURN *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURN(struct soap *soap, const struct ns2__getDataTypeURN *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURN(struct soap *soap, const struct ns2__getDataTypeURN *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURN);
  if (soap_out_ns2__getDataTypeURN(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURN(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURN *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURN), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURN * SOAP_FMAC4 soap_get_ns2__getDataTypeURN(struct soap *soap, struct ns2__getDataTypeURN *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURN(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURN * SOAP_FMAC4 soap_in_ns2__getDataTypeURN(struct soap *soap, const char *tag, struct ns2__getDataTypeURN *a, const char *type)
  {
    size_t soap_flag__name = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURN *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURN, sizeof(struct ns2__getDataTypeURN), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURN(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURN *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURN, 0, sizeof(struct ns2__getDataTypeURN), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURN * SOAP_FMAC6 soap_new_ns2__getDataTypeURN(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURN(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURN(struct soap *soap, struct ns2__getDataTypeURN *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURN * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURN(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURN(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURN, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURN;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURN);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURN[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURN);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURN*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURN(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURN %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURN*)p = *(struct ns2__getDataTypeURN*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getDataTypeURNResponse(struct soap *soap, struct ns2__getDataTypeURNResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getDataTypeURNReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getDataTypeURNResponse(struct soap *soap, const struct ns2__getDataTypeURNResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getDataTypeURNReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getDataTypeURNResponse(struct soap *soap, const struct ns2__getDataTypeURNResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getDataTypeURNResponse);
  if (soap_out_ns2__getDataTypeURNResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getDataTypeURNResponse(struct soap *soap, const char *tag, int id, const struct ns2__getDataTypeURNResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getDataTypeURNResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getDataTypeURNReturn", -1, &a->_getDataTypeURNReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getDataTypeURNResponse * SOAP_FMAC4 soap_get_ns2__getDataTypeURNResponse(struct soap *soap, struct ns2__getDataTypeURNResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getDataTypeURNResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getDataTypeURNResponse * SOAP_FMAC4 soap_in_ns2__getDataTypeURNResponse(struct soap *soap, const char *tag, struct ns2__getDataTypeURNResponse *a, const char *type)
  {
    size_t soap_flag__getDataTypeURNReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getDataTypeURNResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getDataTypeURNResponse, sizeof(struct ns2__getDataTypeURNResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getDataTypeURNResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getDataTypeURNReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getDataTypeURNReturn, "xsd:string"))
                {
                  soap_flag__getDataTypeURNReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getDataTypeURNResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getDataTypeURNResponse, 0, sizeof(struct ns2__getDataTypeURNResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getDataTypeURNReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getDataTypeURNResponse * SOAP_FMAC6 soap_new_ns2__getDataTypeURNResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getDataTypeURNResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getDataTypeURNResponse(struct soap *soap, struct ns2__getDataTypeURNResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getDataTypeURNResponse * SOAP_FMAC4 soap_instantiate_ns2__getDataTypeURNResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getDataTypeURNResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getDataTypeURNResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURNResponse;
        if (size)
          *size = sizeof(struct ns2__getDataTypeURNResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getDataTypeURNResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getDataTypeURNResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getDataTypeURNResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getDataTypeURNResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getDataTypeURNResponse %p -> %p\n", q, p));
  *(struct ns2__getDataTypeURNResponse*)p = *(struct ns2__getDataTypeURNResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getJavaLibraryVersion(struct soap *soap, struct ns2__getJavaLibraryVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getJavaLibraryVersion(struct soap *soap, const struct ns2__getJavaLibraryVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getJavaLibraryVersion(struct soap *soap, const struct ns2__getJavaLibraryVersion *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getJavaLibraryVersion);
  if (soap_out_ns2__getJavaLibraryVersion(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getJavaLibraryVersion(struct soap *soap, const char *tag, int id, const struct ns2__getJavaLibraryVersion *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getJavaLibraryVersion), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersion * SOAP_FMAC4 soap_get_ns2__getJavaLibraryVersion(struct soap *soap, struct ns2__getJavaLibraryVersion *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getJavaLibraryVersion(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getJavaLibraryVersion * SOAP_FMAC4 soap_in_ns2__getJavaLibraryVersion(struct soap *soap, const char *tag, struct ns2__getJavaLibraryVersion *a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getJavaLibraryVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getJavaLibraryVersion, sizeof(struct ns2__getJavaLibraryVersion), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getJavaLibraryVersion(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getJavaLibraryVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getJavaLibraryVersion, 0, sizeof(struct ns2__getJavaLibraryVersion), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getJavaLibraryVersion * SOAP_FMAC6 soap_new_ns2__getJavaLibraryVersion(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getJavaLibraryVersion(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getJavaLibraryVersion(struct soap *soap, struct ns2__getJavaLibraryVersion *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersion * SOAP_FMAC4 soap_instantiate_ns2__getJavaLibraryVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getJavaLibraryVersion(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getJavaLibraryVersion, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getJavaLibraryVersion;
        if (size)
          *size = sizeof(struct ns2__getJavaLibraryVersion);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getJavaLibraryVersion[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getJavaLibraryVersion);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getJavaLibraryVersion*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getJavaLibraryVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getJavaLibraryVersion %p -> %p\n", q, p));
  *(struct ns2__getJavaLibraryVersion*)p = *(struct ns2__getJavaLibraryVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getJavaLibraryVersionResponse(struct soap *soap, struct ns2__getJavaLibraryVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->getJavaLibraryVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getJavaLibraryVersionResponse(struct soap *soap, const struct ns2__getJavaLibraryVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->getJavaLibraryVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getJavaLibraryVersionResponse(struct soap *soap, const struct ns2__getJavaLibraryVersionResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getJavaLibraryVersionResponse);
  if (soap_out_ns2__getJavaLibraryVersionResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getJavaLibraryVersionResponse(struct soap *soap, const char *tag, int id, const struct ns2__getJavaLibraryVersionResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getJavaLibraryVersionResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getJavaLibraryVersionReturn", -1, &a->getJavaLibraryVersionReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC4 soap_get_ns2__getJavaLibraryVersionResponse(struct soap *soap, struct ns2__getJavaLibraryVersionResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getJavaLibraryVersionResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC4 soap_in_ns2__getJavaLibraryVersionResponse(struct soap *soap, const char *tag, struct ns2__getJavaLibraryVersionResponse *a, const char *type)
  {
    size_t soap_flag_getJavaLibraryVersionReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getJavaLibraryVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getJavaLibraryVersionResponse, sizeof(struct ns2__getJavaLibraryVersionResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getJavaLibraryVersionResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_getJavaLibraryVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "getJavaLibraryVersionReturn", &a->getJavaLibraryVersionReturn, "xsd:string"))
                {
                  soap_flag_getJavaLibraryVersionReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getJavaLibraryVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getJavaLibraryVersionResponse, 0, sizeof(struct ns2__getJavaLibraryVersionResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getJavaLibraryVersionReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC6 soap_new_ns2__getJavaLibraryVersionResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getJavaLibraryVersionResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getJavaLibraryVersionResponse(struct soap *soap, struct ns2__getJavaLibraryVersionResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getJavaLibraryVersionResponse * SOAP_FMAC4 soap_instantiate_ns2__getJavaLibraryVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getJavaLibraryVersionResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getJavaLibraryVersionResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getJavaLibraryVersionResponse;
        if (size)
          *size = sizeof(struct ns2__getJavaLibraryVersionResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getJavaLibraryVersionResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getJavaLibraryVersionResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getJavaLibraryVersionResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getJavaLibraryVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getJavaLibraryVersionResponse %p -> %p\n", q, p));
  *(struct ns2__getJavaLibraryVersionResponse*)p = *(struct ns2__getJavaLibraryVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesVersion(struct soap *soap, struct ns2__getServicesVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesVersion(struct soap *soap, const struct ns2__getServicesVersion *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesVersion(struct soap *soap, const struct ns2__getServicesVersion *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesVersion);
  if (soap_out_ns2__getServicesVersion(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesVersion(struct soap *soap, const char *tag, int id, const struct ns2__getServicesVersion *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesVersion), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesVersion * SOAP_FMAC4 soap_get_ns2__getServicesVersion(struct soap *soap, struct ns2__getServicesVersion *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getServicesVersion(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getServicesVersion * SOAP_FMAC4 soap_in_ns2__getServicesVersion(struct soap *soap, const char *tag, struct ns2__getServicesVersion *a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getServicesVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesVersion, sizeof(struct ns2__getServicesVersion), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getServicesVersion(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getServicesVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesVersion, 0, sizeof(struct ns2__getServicesVersion), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getServicesVersion * SOAP_FMAC6 soap_new_ns2__getServicesVersion(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getServicesVersion(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesVersion(struct soap *soap, struct ns2__getServicesVersion *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesVersion * SOAP_FMAC4 soap_instantiate_ns2__getServicesVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesVersion(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesVersion, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getServicesVersion;
        if (size)
          *size = sizeof(struct ns2__getServicesVersion);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getServicesVersion[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getServicesVersion);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getServicesVersion*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesVersion %p -> %p\n", q, p));
  *(struct ns2__getServicesVersion*)p = *(struct ns2__getServicesVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesVersionResponse(struct soap *soap, struct ns2__getServicesVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->getServicesVersionReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesVersionResponse(struct soap *soap, const struct ns2__getServicesVersionResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->getServicesVersionReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesVersionResponse(struct soap *soap, const struct ns2__getServicesVersionResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesVersionResponse);
  if (soap_out_ns2__getServicesVersionResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesVersionResponse(struct soap *soap, const char *tag, int id, const struct ns2__getServicesVersionResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesVersionResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getServicesVersionReturn", -1, &a->getServicesVersionReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesVersionResponse * SOAP_FMAC4 soap_get_ns2__getServicesVersionResponse(struct soap *soap, struct ns2__getServicesVersionResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getServicesVersionResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getServicesVersionResponse * SOAP_FMAC4 soap_in_ns2__getServicesVersionResponse(struct soap *soap, const char *tag, struct ns2__getServicesVersionResponse *a, const char *type)
  {
    size_t soap_flag_getServicesVersionReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getServicesVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesVersionResponse, sizeof(struct ns2__getServicesVersionResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getServicesVersionResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_getServicesVersionReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "getServicesVersionReturn", &a->getServicesVersionReturn, "xsd:string"))
                {
                  soap_flag_getServicesVersionReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getServicesVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesVersionResponse, 0, sizeof(struct ns2__getServicesVersionResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getServicesVersionReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getServicesVersionResponse * SOAP_FMAC6 soap_new_ns2__getServicesVersionResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getServicesVersionResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesVersionResponse(struct soap *soap, struct ns2__getServicesVersionResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesVersionResponse * SOAP_FMAC4 soap_instantiate_ns2__getServicesVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesVersionResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesVersionResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getServicesVersionResponse;
        if (size)
          *size = sizeof(struct ns2__getServicesVersionResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getServicesVersionResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getServicesVersionResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getServicesVersionResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesVersionResponse %p -> %p\n", q, p));
  *(struct ns2__getServicesVersionResponse*)p = *(struct ns2__getServicesVersionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesInfo(struct soap *soap, struct ns2__getServicesInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesInfo(struct soap *soap, const struct ns2__getServicesInfo *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesInfo(struct soap *soap, const struct ns2__getServicesInfo *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesInfo);
  if (soap_out_ns2__getServicesInfo(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesInfo(struct soap *soap, const char *tag, int id, const struct ns2__getServicesInfo *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesInfo), type))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesInfo * SOAP_FMAC4 soap_get_ns2__getServicesInfo(struct soap *soap, struct ns2__getServicesInfo *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getServicesInfo(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getServicesInfo * SOAP_FMAC4 soap_in_ns2__getServicesInfo(struct soap *soap, const char *tag, struct ns2__getServicesInfo *a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getServicesInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesInfo, sizeof(struct ns2__getServicesInfo), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getServicesInfo(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getServicesInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesInfo, 0, sizeof(struct ns2__getServicesInfo), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getServicesInfo * SOAP_FMAC6 soap_new_ns2__getServicesInfo(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getServicesInfo(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesInfo(struct soap *soap, struct ns2__getServicesInfo *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesInfo * SOAP_FMAC4 soap_instantiate_ns2__getServicesInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesInfo(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesInfo, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getServicesInfo;
        if (size)
          *size = sizeof(struct ns2__getServicesInfo);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getServicesInfo[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getServicesInfo);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getServicesInfo*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesInfo %p -> %p\n", q, p));
  *(struct ns2__getServicesInfo*)p = *(struct ns2__getServicesInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getServicesInfoResponse(struct soap *soap, struct ns2__getServicesInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->getServicesInfoReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getServicesInfoResponse(struct soap *soap, const struct ns2__getServicesInfoResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->getServicesInfoReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getServicesInfoResponse(struct soap *soap, const struct ns2__getServicesInfoResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getServicesInfoResponse);
  if (soap_out_ns2__getServicesInfoResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getServicesInfoResponse(struct soap *soap, const char *tag, int id, const struct ns2__getServicesInfoResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getServicesInfoResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getServicesInfoReturn", -1, &a->getServicesInfoReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getServicesInfoResponse * SOAP_FMAC4 soap_get_ns2__getServicesInfoResponse(struct soap *soap, struct ns2__getServicesInfoResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getServicesInfoResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getServicesInfoResponse * SOAP_FMAC4 soap_in_ns2__getServicesInfoResponse(struct soap *soap, const char *tag, struct ns2__getServicesInfoResponse *a, const char *type)
  {
    size_t soap_flag_getServicesInfoReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getServicesInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getServicesInfoResponse, sizeof(struct ns2__getServicesInfoResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getServicesInfoResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag_getServicesInfoReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, "getServicesInfoReturn", &a->getServicesInfoReturn, "xsd:string"))
                {
                  soap_flag_getServicesInfoReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getServicesInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getServicesInfoResponse, 0, sizeof(struct ns2__getServicesInfoResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_getServicesInfoReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getServicesInfoResponse * SOAP_FMAC6 soap_new_ns2__getServicesInfoResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getServicesInfoResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getServicesInfoResponse(struct soap *soap, struct ns2__getServicesInfoResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getServicesInfoResponse * SOAP_FMAC4 soap_instantiate_ns2__getServicesInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getServicesInfoResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getServicesInfoResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getServicesInfoResponse;
        if (size)
          *size = sizeof(struct ns2__getServicesInfoResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getServicesInfoResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getServicesInfoResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getServicesInfoResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getServicesInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getServicesInfoResponse %p -> %p\n", q, p));
  *(struct ns2__getServicesInfoResponse*)p = *(struct ns2__getServicesInfoResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURI_(struct soap *soap, struct ns2__getURI_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_id);
  soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURI_(struct soap *soap, const struct ns2__getURI_ *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_id);
  soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURI_(struct soap *soap, const struct ns2__getURI_ *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURI_);
  if (soap_out_ns2__getURI_(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURI_(struct soap *soap, const char *tag, int id, const struct ns2__getURI_ *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURI_), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  if (soap_out_string(soap, "type", -1, &a->_type, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURI_ * SOAP_FMAC4 soap_get_ns2__getURI_(struct soap *soap, struct ns2__getURI_ *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURI_(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURI_ * SOAP_FMAC4 soap_in_ns2__getURI_(struct soap *soap, const char *tag, struct ns2__getURI_ *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__id = 1;
    size_t soap_flag__type = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURI_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURI_, sizeof(struct ns2__getURI_), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURI_(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
                {
                  soap_flag__type--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURI_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURI_, 0, sizeof(struct ns2__getURI_), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURI_ * SOAP_FMAC6 soap_new_ns2__getURI_(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURI_(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURI_(struct soap *soap, struct ns2__getURI_ *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURI_ * SOAP_FMAC4 soap_instantiate_ns2__getURI_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURI_(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURI_, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURI_;
        if (size)
          *size = sizeof(struct ns2__getURI_);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURI_[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURI_);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURI_*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURI_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURI_ %p -> %p\n", q, p));
  *(struct ns2__getURI_*)p = *(struct ns2__getURI_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURI_Response(struct soap *soap, struct ns2__getURI_Response *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURI_Response(struct soap *soap, const struct ns2__getURI_Response *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURI_Response(struct soap *soap, const struct ns2__getURI_Response *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURI_Response);
  if (soap_out_ns2__getURI_Response(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURI_Response(struct soap *soap, const char *tag, int id, const struct ns2__getURI_Response *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURI_Response), type))
    return soap->error;
  if (soap_out_string(soap, "getURIReturn", -1, &a->_getURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURI_Response * SOAP_FMAC4 soap_get_ns2__getURI_Response(struct soap *soap, struct ns2__getURI_Response *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURI_Response(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURI_Response * SOAP_FMAC4 soap_in_ns2__getURI_Response(struct soap *soap, const char *tag, struct ns2__getURI_Response *a, const char *type)
  {
    size_t soap_flag__getURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURI_Response *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURI_Response, sizeof(struct ns2__getURI_Response), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURI_Response(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getURIReturn, "xsd:string"))
                {
                  soap_flag__getURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURI_Response *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURI_Response, 0, sizeof(struct ns2__getURI_Response), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURI_Response * SOAP_FMAC6 soap_new_ns2__getURI_Response(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURI_Response(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURI_Response(struct soap *soap, struct ns2__getURI_Response *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURI_Response * SOAP_FMAC4 soap_instantiate_ns2__getURI_Response(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURI_Response(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURI_Response, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURI_Response;
        if (size)
          *size = sizeof(struct ns2__getURI_Response);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURI_Response[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURI_Response);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURI_Response*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURI_Response(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURI_Response %p -> %p\n", q, p));
  *(struct ns2__getURI_Response*)p = *(struct ns2__getURI_Response*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURI(struct soap *soap, struct ns2__getURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_id);
  soap_default_string(soap, &a->_type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURI(struct soap *soap, const struct ns2__getURI *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_id);
  soap_serialize_string(soap, &a->_type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURI(struct soap *soap, const struct ns2__getURI *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURI);
  if (soap_out_ns2__getURI(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURI(struct soap *soap, const char *tag, int id, const struct ns2__getURI *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURI), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  if (soap_out_string(soap, "type", -1, &a->_type, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURI * SOAP_FMAC4 soap_get_ns2__getURI(struct soap *soap, struct ns2__getURI *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURI(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURI * SOAP_FMAC4 soap_in_ns2__getURI(struct soap *soap, const char *tag, struct ns2__getURI *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__id = 1;
    size_t soap_flag__type = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURI, sizeof(struct ns2__getURI), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURI(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap_flag__type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_type, "xsd:string"))
                {
                  soap_flag__type--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURI, 0, sizeof(struct ns2__getURI), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURI * SOAP_FMAC6 soap_new_ns2__getURI(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURI(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURI(struct soap *soap, struct ns2__getURI *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURI * SOAP_FMAC4 soap_instantiate_ns2__getURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURI(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURI, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURI;
        if (size)
          *size = sizeof(struct ns2__getURI);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURI[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURI);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURI*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURI %p -> %p\n", q, p));
  *(struct ns2__getURI*)p = *(struct ns2__getURI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURIResponse(struct soap *soap, struct ns2__getURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getURIReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURIResponse(struct soap *soap, const struct ns2__getURIResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getURIReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURIResponse(struct soap *soap, const struct ns2__getURIResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURIResponse);
  if (soap_out_ns2__getURIResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURIResponse(struct soap *soap, const char *tag, int id, const struct ns2__getURIResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURIResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getURIReturn", -1, &a->_getURIReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURIResponse * SOAP_FMAC4 soap_get_ns2__getURIResponse(struct soap *soap, struct ns2__getURIResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURIResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURIResponse * SOAP_FMAC4 soap_in_ns2__getURIResponse(struct soap *soap, const char *tag, struct ns2__getURIResponse *a, const char *type)
  {
    size_t soap_flag__getURIReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURIResponse, sizeof(struct ns2__getURIResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURIResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getURIReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getURIReturn, "xsd:string"))
                {
                  soap_flag__getURIReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURIResponse, 0, sizeof(struct ns2__getURIResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getURIReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURIResponse * SOAP_FMAC6 soap_new_ns2__getURIResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURIResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURIResponse(struct soap *soap, struct ns2__getURIResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURIResponse * SOAP_FMAC4 soap_instantiate_ns2__getURIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURIResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURIResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURIResponse;
        if (size)
          *size = sizeof(struct ns2__getURIResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURIResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURIResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURIResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURIResponse %p -> %p\n", q, p));
  *(struct ns2__getURIResponse*)p = *(struct ns2__getURIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURL(struct soap *soap, struct ns2__getURL *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_name);
  soap_default_string(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURL(struct soap *soap, const struct ns2__getURL *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_name);
  soap_serialize_string(soap, &a->_id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURL(struct soap *soap, const struct ns2__getURL *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURL);
  if (soap_out_ns2__getURL(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURL(struct soap *soap, const char *tag, int id, const struct ns2__getURL *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURL), type))
    return soap->error;
  if (soap_out_string(soap, "name", -1, &a->_name, ""))
    return soap->error;
  if (soap_out_string(soap, "id", -1, &a->_id, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURL * SOAP_FMAC4 soap_get_ns2__getURL(struct soap *soap, struct ns2__getURL *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURL(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURL * SOAP_FMAC4 soap_in_ns2__getURL(struct soap *soap, const char *tag, struct ns2__getURL *a, const char *type)
  {
    size_t soap_flag__name = 1;
    size_t soap_flag__id = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURL, sizeof(struct ns2__getURL), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURL(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_name, "xsd:string"))
                {
                  soap_flag__name--;
                  continue;
                }
            if (soap_flag__id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_id, "xsd:string"))
                {
                  soap_flag__id--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURL, 0, sizeof(struct ns2__getURL), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURL * SOAP_FMAC6 soap_new_ns2__getURL(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURL(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURL(struct soap *soap, struct ns2__getURL *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURL * SOAP_FMAC4 soap_instantiate_ns2__getURL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURL(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURL, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURL;
        if (size)
          *size = sizeof(struct ns2__getURL);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURL[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURL);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURL*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURL(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURL %p -> %p\n", q, p));
  *(struct ns2__getURL*)p = *(struct ns2__getURL*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getURLResponse(struct soap *soap, struct ns2__getURLResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getURLReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getURLResponse(struct soap *soap, const struct ns2__getURLResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getURLReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getURLResponse(struct soap *soap, const struct ns2__getURLResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getURLResponse);
  if (soap_out_ns2__getURLResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getURLResponse(struct soap *soap, const char *tag, int id, const struct ns2__getURLResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getURLResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getURLReturn", -1, &a->_getURLReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getURLResponse * SOAP_FMAC4 soap_get_ns2__getURLResponse(struct soap *soap, struct ns2__getURLResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getURLResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getURLResponse * SOAP_FMAC4 soap_in_ns2__getURLResponse(struct soap *soap, const char *tag, struct ns2__getURLResponse *a, const char *type)
  {
    size_t soap_flag__getURLReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getURLResponse, sizeof(struct ns2__getURLResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getURLResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getURLReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getURLReturn, "xsd:string"))
                {
                  soap_flag__getURLReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getURLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getURLResponse, 0, sizeof(struct ns2__getURLResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getURLReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getURLResponse * SOAP_FMAC6 soap_new_ns2__getURLResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getURLResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getURLResponse(struct soap *soap, struct ns2__getURLResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getURLResponse * SOAP_FMAC4 soap_instantiate_ns2__getURLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getURLResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getURLResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getURLResponse;
        if (size)
          *size = sizeof(struct ns2__getURLResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getURLResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getURLResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getURLResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getURLResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getURLResponse %p -> %p\n", q, p));
  *(struct ns2__getURLResponse*)p = *(struct ns2__getURLResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocation(struct soap *soap, struct ns2__getLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
  soap_default_string(soap, &a->_resource);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocation(struct soap *soap, const struct ns2__getLocation *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
  soap_serialize_string(soap, &a->_resource);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocation(struct soap *soap, const struct ns2__getLocation *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocation);
  if (soap_out_ns2__getLocation(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocation(struct soap *soap, const char *tag, int id, const struct ns2__getLocation *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocation), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  if (soap_out_string(soap, "resource", -1, &a->_resource, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocation * SOAP_FMAC4 soap_get_ns2__getLocation(struct soap *soap, struct ns2__getLocation *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getLocation(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getLocation * SOAP_FMAC4 soap_in_ns2__getLocation(struct soap *soap, const char *tag, struct ns2__getLocation *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    size_t soap_flag__resource = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getLocation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocation, sizeof(struct ns2__getLocation), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getLocation(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap_flag__resource && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_resource, "xsd:string"))
                {
                  soap_flag__resource--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocation, 0, sizeof(struct ns2__getLocation), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getLocation * SOAP_FMAC6 soap_new_ns2__getLocation(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getLocation(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocation(struct soap *soap, struct ns2__getLocation *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocation * SOAP_FMAC4 soap_instantiate_ns2__getLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocation(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocation, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getLocation;
        if (size)
          *size = sizeof(struct ns2__getLocation);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getLocation[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getLocation);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getLocation*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocation %p -> %p\n", q, p));
  *(struct ns2__getLocation*)p = *(struct ns2__getLocation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getLocationResponse(struct soap *soap, struct ns2__getLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getLocationReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getLocationResponse(struct soap *soap, const struct ns2__getLocationResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getLocationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getLocationResponse(struct soap *soap, const struct ns2__getLocationResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getLocationResponse);
  if (soap_out_ns2__getLocationResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getLocationResponse(struct soap *soap, const char *tag, int id, const struct ns2__getLocationResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getLocationResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getLocationReturn", -1, &a->_getLocationReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getLocationResponse * SOAP_FMAC4 soap_get_ns2__getLocationResponse(struct soap *soap, struct ns2__getLocationResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getLocationResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getLocationResponse * SOAP_FMAC4 soap_in_ns2__getLocationResponse(struct soap *soap, const char *tag, struct ns2__getLocationResponse *a, const char *type)
  {
    size_t soap_flag__getLocationReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getLocationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getLocationResponse, sizeof(struct ns2__getLocationResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getLocationResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getLocationReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getLocationReturn, "xsd:string"))
                {
                  soap_flag__getLocationReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getLocationResponse, 0, sizeof(struct ns2__getLocationResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getLocationReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getLocationResponse * SOAP_FMAC6 soap_new_ns2__getLocationResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getLocationResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getLocationResponse(struct soap *soap, struct ns2__getLocationResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getLocationResponse * SOAP_FMAC4 soap_instantiate_ns2__getLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getLocationResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getLocationResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getLocationResponse;
        if (size)
          *size = sizeof(struct ns2__getLocationResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getLocationResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getLocationResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getLocationResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getLocationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getLocationResponse %p -> %p\n", q, p));
  *(struct ns2__getLocationResponse*)p = *(struct ns2__getLocationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getName(struct soap *soap, struct ns2__getName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getName(struct soap *soap, const struct ns2__getName *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_uri);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getName(struct soap *soap, const struct ns2__getName *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getName);
  if (soap_out_ns2__getName(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getName(struct soap *soap, const char *tag, int id, const struct ns2__getName *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getName), type))
    return soap->error;
  if (soap_out_string(soap, "uri", -1, &a->_uri, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getName * SOAP_FMAC4 soap_get_ns2__getName(struct soap *soap, struct ns2__getName *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getName(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getName * SOAP_FMAC4 soap_in_ns2__getName(struct soap *soap, const char *tag, struct ns2__getName *a, const char *type)
  {
    size_t soap_flag__uri = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getName, sizeof(struct ns2__getName), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getName(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_uri, "xsd:string"))
                {
                  soap_flag__uri--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getName, 0, sizeof(struct ns2__getName), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getName * SOAP_FMAC6 soap_new_ns2__getName(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getName(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getName(struct soap *soap, struct ns2__getName *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getName * SOAP_FMAC4 soap_instantiate_ns2__getName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getName(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getName, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getName;
        if (size)
          *size = sizeof(struct ns2__getName);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getName[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getName);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getName*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getName %p -> %p\n", q, p));
  *(struct ns2__getName*)p = *(struct ns2__getName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__getNameResponse(struct soap *soap, struct ns2__getNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_default_string(soap, &a->_getNameReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__getNameResponse(struct soap *soap, const struct ns2__getNameResponse *a)
{
  (void)soap; (void)a; /* appease -Wall -Werror */
  soap_serialize_string(soap, &a->_getNameReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__getNameResponse(struct soap *soap, const struct ns2__getNameResponse *a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__getNameResponse);
  if (soap_out_ns2__getNameResponse(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__getNameResponse(struct soap *soap, const char *tag, int id, const struct ns2__getNameResponse *a, const char *type)
{
  if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__getNameResponse), type))
    return soap->error;
  if (soap_out_string(soap, "getNameReturn", -1, &a->_getNameReturn, ""))
    return soap->error;
  return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__getNameResponse * SOAP_FMAC4 soap_get_ns2__getNameResponse(struct soap *soap, struct ns2__getNameResponse *p, const char *tag, const char *type)
  {
    if ((p = soap_in_ns2__getNameResponse(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct ns2__getNameResponse * SOAP_FMAC4 soap_in_ns2__getNameResponse(struct soap *soap, const char *tag, struct ns2__getNameResponse *a, const char *type)
  {
    size_t soap_flag__getNameReturn = 1;
    if (soap_element_begin_in(soap, tag, 0, type))
      return NULL;
    a = (struct ns2__getNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__getNameResponse, sizeof(struct ns2__getNameResponse), 0, NULL, NULL, NULL);
    if (!a)
      return NULL;
    soap_default_ns2__getNameResponse(soap, a);
    if (soap->body && !*soap->href)
      {
        for (;;)
          {
            soap->error = SOAP_TAG_MISMATCH;
            if (soap_flag__getNameReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
              if (soap_in_string(soap, NULL, &a->_getNameReturn, "xsd:string"))
                {
                  soap_flag__getNameReturn--;
                  continue;
                }
            if (soap->error == SOAP_TAG_MISMATCH)
              soap->error = soap_ignore_element(soap);
            if (soap->error == SOAP_NO_TAG)
              break;
            if (soap->error)
              return NULL;
          }
        if (soap_element_end_in(soap, tag))
          return NULL;
      }
    else
      {
        a = (struct ns2__getNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__getNameResponse, 0, sizeof(struct ns2__getNameResponse), 0, NULL);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getNameReturn > 0))
      {
        soap->error = SOAP_OCCURS;
        return NULL;
      }
    return a;
  }

SOAP_FMAC5 struct ns2__getNameResponse * SOAP_FMAC6 soap_new_ns2__getNameResponse(struct soap *soap, int n)
  {
    return soap_instantiate_ns2__getNameResponse(soap, n, NULL, NULL, NULL);
  }

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__getNameResponse(struct soap *soap, struct ns2__getNameResponse *p)
{
  soap_delete(soap, p);
}

SOAP_FMAC3 struct ns2__getNameResponse * SOAP_FMAC4 soap_instantiate_ns2__getNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
  {
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__getNameResponse(%d, %s, %s)\n", n, type ? type : "", arrayType ? arrayType : ""));
    struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__getNameResponse, n, soap_fdelete);
    if (!cp)
      return NULL;
    if (n < 0)
      {
        cp->ptr = (void*)new struct ns2__getNameResponse;
        if (size)
          *size = sizeof(struct ns2__getNameResponse);
      }
    else
      {
        cp->ptr = (void*)new struct ns2__getNameResponse[n];
        if (!cp->ptr)
          {
            soap->error = SOAP_EOM;
            return NULL;
          }
        if (size)
          *size = n * sizeof(struct ns2__getNameResponse);
      }
    DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
    return (struct ns2__getNameResponse*)cp->ptr;
  }
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__getNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__getNameResponse %p -> %p\n", q, p));
  *(struct ns2__getNameResponse*)p = *(struct ns2__getNameResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
    soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
  if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
  {
    if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 1, NULL))
      return NULL;
    if (!a)
      if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
        return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
      {
        soap_revert(soap);
        if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
    soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
  if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
  {
    if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 1, NULL))
      return NULL;
    if (!a)
      if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
        return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
      {
        soap_revert(soap);
        if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
    soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
  if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
  if (id < 0)
    return soap->error;
  return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
  {
    if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
      if (soap_getindependent(soap))
        return NULL;
    return p;
  }

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
  {
    if (soap_element_begin_in(soap, tag, 1, NULL))
      return NULL;
    if (!a)
      if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
        return NULL;
    *a = NULL;
    if (!soap->null && *soap->href != '#')
      {
        soap_revert(soap);
        if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
          return NULL;
      }
    else
      {
        a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
        if (soap->body && soap_element_end_in(soap, tag))
          return NULL;
      }
    return a;
  }

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *const*a)
{
  if (*a)
    (*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCORExsd_USCOREstring);
  if (soap_out_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, int id, ArrayOf_USCORExsd_USCOREstring *const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring);
  if (id < 0)
    return soap->error;
  return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, ArrayOf_USCORExsd_USCOREstring **p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerToArrayOf_USCORExsd_USCOREstring(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 ArrayOf_USCORExsd_USCOREstring ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCORExsd_USCOREstring(struct soap *soap, const char *tag, ArrayOf_USCORExsd_USCOREstring **a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (ArrayOf_USCORExsd_USCOREstring **)soap_malloc(soap, sizeof(ArrayOf_USCORExsd_USCOREstring *))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);
      if (!(*a = (ArrayOf_USCORExsd_USCOREstring *)soap_instantiate_ArrayOf_USCORExsd_USCOREstring(soap, -1, soap->type, soap->arrayType, NULL)))
        return NULL;
      (*a)->soap_default(soap);
      if (!(*a)->soap_in(soap, tag, NULL))
        return NULL;
    }
  else
    {
      ArrayOf_USCORExsd_USCOREstring ** p = (ArrayOf_USCORExsd_USCOREstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCORExsd_USCOREstring, sizeof(ArrayOf_USCORExsd_USCOREstring), 0);
      a = p;
      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
  if (!soap_reference(soap, *a, SOAP_TYPE_string))
    soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
  if (soap_out_PointerTostring(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
  id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
  if (id < 0)
    return soap->error;
  return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
  if ((p = soap_in_PointerTostring(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
  if (soap_element_begin_in(soap, tag, 1, NULL))
    return NULL;
  if (!a)
    if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
      return NULL;
  *a = NULL;
  if (!soap->null && *soap->href != '#')
    {
      soap_revert(soap);
      if (!(*a = soap_in_string(soap, tag, *a, type)))
        return NULL;
    }
  else
    {
      a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
      if (soap->body && soap_element_end_in(soap, tag))
        return NULL;
    }
  return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
  soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
  soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
  if (soap_out__QName(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
  if ((p = soap_in__QName(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
  return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
  (void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
  *a = SOAP_DEFAULT_string;
#else
  *a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
  soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
  register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
  if (soap_out_string(soap, tag, id, a, type))
    return soap->error;
  return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
  return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
  if ((p = soap_in_string(soap, tag, p, type)))
    if (soap_getindependent(soap))
      return NULL;
  return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
  return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of soapC.cpp */
