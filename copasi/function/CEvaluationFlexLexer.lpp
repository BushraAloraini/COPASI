/* scanner for kinetic functions */

%option outfile="CEvaluationFlexLexer.cpp"
%option prefix="CEvaluation"
%option noyywrap
%option never-interactive
%option c++

%{
#include <vector>

#include "copasi.h"
#include "CEvaluationNode.h"
#include "CEvaluationFlexLexer.h"

#define YY_USER_INIT \
    mpNode = NULL;\
    mPosition = 0;\
    mpNodeList = new std::vector< CEvaluationNode * >;

#define YY_BREAK \
    mPosition += yyleng;\
    mpNodeList->push_back(mpNode);\
    break;
%}

DIGIT    [0-9]
ID       [a-z_A-Z][a-z_A-Z0-9]*
   
%%

{DIGIT}+("."?{DIGIT}*(((e|E)"+"?|(e|E)"-"){DIGIT}+)?)?  mpNode = new CEvaluationNodeNumber(CEvaluationNodeNumber::DOUBLE, yytext);
 
(log|LOG)/\(   return 0; // CEvaluationNodeFunction::LOG;

(log10|LOG10)/\( return 0; // CEvaluationNodeFunction::LOG10;

(exp|EXP)/\(   return 0; // CEvaluationNodeFunction::EXP;

(sin|SIN)/\(   return 0; // CEvaluationNodeFunction::SIN;

(cos|COS)/\(   return 0; // CEvaluationNodeFunction::COS;

(tan|TAN)/\(   return 0; // CEvaluationNodeFunction::TAN;

(sec|SEC)/\(   return 0; // CEvaluationNodeFunction::SEC;

(csc|CSC)/\(   return 0; // CEvaluationNodeFunction::CSC;

(cot|COT)/\(   return 0; // CEvaluationNodeFunction::COT;

(sinh|SINH)/\(   return 0; // CEvaluationNodeFunction::SINH;

(cosh|COSH)/\(   return 0; // CEvaluationNodeFunction::COSH;

(tanh|TANH)/\(   return 0; // CEvaluationNodeFunction::TANH;

(sech|SECH)/\(   return 0; // CEvaluationNodeFunction::SECH;

(csch|CSCH)/\(   return 0; // CEvaluationNodeFunction::CSCH;

(coth|COTH)/\(   return 0; // CEvaluationNodeFunction::COTH;

(asin|ASIN)/\(   return 0; // CEvaluationNodeFunction::ARCSIN;

(acos|ACOS)/\(   return 0; // CEvaluationNodeFunction::ARCCOS;

(atan|ATAN)/\(   return 0; // CEvaluationNodeFunction::ARCTAN;

(arcsec|ARCSEC)/\(   return 0; // CEvaluationNodeFunction::ARCSEC;

(arccsc|ARCCSC)/\(   return 0; // CEvaluationNodeFunction::ARCCSC;

(arccot|ARCCOT)/\(   return 0; // CEvaluationNodeFunction::ARCCOT;

(arcsinh|ARCSINH)/\(   return 0; // CEvaluationNodeFunction::ARCSINH;

(arccosh|ARCCOSH)/\(   return 0; // CEvaluationNodeFunction::ARCCOSH;

(arctanh|ARCTANH)/\(   return 0; // CEvaluationNodeFunction::ARCTANH;

(arcsech|ARCSECH)/\(   return 0; // CEvaluationNodeFunction::ARCSECH;
 
(arccsch|ARCCSCH)/\(   return 0; // CEvaluationNodeFunction::ARCCSCH;

(arccoth|ARCCOTH)/\(   return 0; // CEvaluationNodeFunction::ARCCOTH;

(sqrt|SQRT)/\(   return 0; // CEvaluationNodeFunction::SQRT;

(abs|ABS)/\(   return 0; // CEvaluationNodeFunction::ABS;

exponentiale |
EXPONENTIALE mpNode = new CEvaluationNodeConstant(CEvaluationNodeConstant::EXPONENTIALE, yytext);

pi |
PI mpNode = new CEvaluationNodeConstant(CEvaluationNodeConstant::PI, yytext);
      
"^"   mpNode = new CEvaluationNodeOperator(CEvaluationNodeOperator::POWER, yytext);

"*"   mpNode = new CEvaluationNodeOperator(CEvaluationNodeOperator::MULTIPLY, yytext);

"/"   mpNode = new CEvaluationNodeOperator(CEvaluationNodeOperator::DIVIDE, yytext);

"%"   mpNode = new CEvaluationNodeOperator(CEvaluationNodeOperator::MODULUS, yytext);

"+"   mpNode = new CEvaluationNodeOperator(CEvaluationNodeOperator::PLUS, yytext);

"-"   mpNode = new CEvaluationNodeOperator(CEvaluationNodeOperator::MINUS, yytext);

"("   return 0; // '(';
"'"   return 0; // ',';
")"   return 0; // ')';

{ID}  return 0; // CEvaluationNodeVariable::IDENTIFIER;

\<([^\\\>]|\\.)*\>  return 0; // CEvaluationNodeObject::OBJECT;
     
[ \t\r\n]+ /* eat up whitespace */
     
.     freeNodeList(mpNodeList); return mPosition;
     
%%
