\documentclass[a4,12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[usenames]{color}
\usepackage{listings}
\usepackage{hyperref}

\begin{document}
\lstset{ %
language=Java,                   % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
keywordstyle=\color{black}\bfseries, % print keywords bold  
commentstyle=\color{blue},      % blue comments 
stringstyle=\ttfamily,          % typewriter type for strings 
showstringspaces=false,         % underline spaces within strings
numbers=left,                   % where to put the line-numbers
numberstyle=\tiny,              % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces within strings adding particular underscores
showtabs=false,                 % show tabs within strings adding particular underscores
escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\title{Documentation for the Java bindings for COPASI}
\author{Ralph Gauges}
\date{\today}
\maketitle
\parindent=0cm
\section{Working with the model}
\subsection{COPASIs Model Concept}
In COPASI, the top level class in the backend is C\textit{CopasiDataModel}. This class contains the actual model as well as the tasks, the function database and all the output definitions (plots and reports). Right now, this class defines one global static instance of itself and many methods in COPASIs backend rely on and work with this instance. Creating a second instance  of \textit{CCopasiDataModel} therefore does not make much sense and will most likely lead to crashes sooner or later. If you work with the COPASI bindings, you are restricted to this one global instance which means that working with more than one model at any given time on one machine is not possible right now.
\textit{CCopasiDataModel} provides the static method \textit{getGlobal()} to get the global static instance of \textit{CCopasiDataModel}.

\begin{lstlisting}
CCopasiDataModel globalModel=CCopasiDataModel.getGlobal();
\end{lstlisting}

\textit{CCopasiDataModel} contains the actual model which can be obtained with the method \textit{getModel()}, the defined tasks which can be obtained with the method \textit{getTaskList()}, the reports which are obtained via the method \textit{getReportDefinitionList()} and the function database which can be obtained with the \textit{getFunctionList()}.
In addition to these methods \textit{CCopasiDataModel} provides some methods for loading COPASI files or importing SBML files, for saving COPASI files or exporting SBML files, for creating new models and for adding tasks to the task list.

\subsection{Model Elements}
The class in COPASI that contains the actual model data is \textit{CModel}. The current model can be obtained from the global static instance of \textit{CCopasiDataModel} via the \textit{getModel()} method. To create a new empty model, \textit{CCopasiDataModel} provides the method \textit{newModel()}. There is also the method \textit{loadModel(String filename)} which loads a COPASI model from the given filename, the method \textit{importSBML(String filename)} which imports an SBML model from the file with the given name and last but not least the method \textit{importSBMLFromString(String sbmlModelText)} which imports an SBML model from the given string. The string must be a valid SBML model string. All three methods return a boolean value which is \textbf{TRUE} if the method succeeded and \textbf{FALSE} otherwise.

Once the model has been obtained, it can be manipulated in many ways. New model elements like compartments, metabolites, reactions and/or global parameters can be created, modified or removed. The model also has some methods to manipulate the time-, volume- and substance units of the model. Unlike SBML, models in COPASI only have global units and the units of all elements of the model are made up of thise global units. Units on individual elements are not supported.

To find out how many compartments, metabolites, reactions or global parameters (model values) a model has, \textit{CModel} has the following methods.

\begin{lstlisting}
long getNumCompartments(); // return the number of compartments in the model
long getNumMetabs(); // return the number of metabolites in the model
long getNumModelValues(); // return the number of global parameters in the model
long getNumReactions(); // return the number of reactions in the model
\end{lstlisting}

To obtain a specific model element there are the following methods:

\begin{lstlisting}
CCompartment getCompartment(long index);
CMetab getMetabolite(long index);
CModelValue getModelValue(long index);
CReaction getReaction(long index);
\end{lstlisting}

New model elements can be created with the following methods:

\begin{lstlisting}
/**
 * Creates a new compartment with the given name and an initial volume of 1.0 volume units.
 * The newly created compartment is added to the model and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CCompartment createCompartment(String name);

/**
 * Creates a new compartment with the given name and initial volume.
 * The newly created compartment is added to the model and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CCompartment createCompartment(String name,double volume);

/**
 * Creates a new metabolite with the given name and an initial concentration of 1.0 substance units/volume units.
 * The metabolite is added to the compartment that is specified as the second argument.
 * The newly created metabolite is added to the model and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CMetab createMetabolite(String name, String compartment);

/**
 * Creates a new metabolite with the given name and initial concentration.
 * The metabolite is added to the compartment that is specified as the second argument.
 * The newly created metabolite is added to the model and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CMetab createMetabolite(String name, String compartment, double iconc);

/**
 * Creates a new model value with the given name and an initial value of 0.0.
 * The newly created model value is added to the model and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CModelValue createModelValue(String name);

/**
 * Creates a new model value with the given name and initial value.
 * The newly created model value is added to the model and the method also returns the new instance.
 * If the method fails, null is returned.
 */
CModelValue createModelValue(String name, double value);

/**
 * Creates a new reaction with the given name.
 * The newly created reaction is added to the model and the method also returns the reaction instance.
 */
CReaction createReaction(String name);
\end{lstlisting}

Naturally model elements can also be removed via their keys. Each object in COPASI which is derived from \textit{CCopasiObject} gets a unique id when it is created which in COPASI is called key. To get the key for such an object, \textit{CCopasiObject} provides the method \textit{getKey()}.
\textit{CModel}, \textit{CCompartment}, \textit{CMetab}, \textit{CModelValue} and \textit{CReaction} are all derived from \textit{CCOpasiObject} and you can therefore get the key for any of them via the \textit{getKey()} method which returns the key in the form of a String.

The methods to delete elements from the model are:

\begin{lstlisting}
boolean removeCompartment(String key);
boolean removeMetabolite(String key);
boolean removeModelValue(String key);
boolean removeReaction(String key);
\end{lstlisting}

These methods also delete all dependent objects. So if a compartment is deleted, all metabolites in that compartment are also deleted and if those metabolites were part of reaction those reactions are deleted as well.

For example, to delete the third metabolite in the model you could write the following code (provided that threre are at least three metabolites in the model):

\begin{lstlisting}
CModel model=globalDataModel.getModel();
CMetab metab=model.getMetabolite(3);
String key=metab.getKey();
model.removeMetabolite(key);
\end{lstlisting}

\subsubsection{CModelEntity}
In COPASI the classes for the model itself, for compartments, metabolites and global parameters are derived from \textit{CModelEntity} and inherit all its methods.
Most of the time, if you manipulate any of those classes, it will be done through methods from \textit{CModelEntity}.
\textit{CModelEntity} provides the following methods:

\begin{lstlisting}
  /**
   * Gets the status of the entity.
   */
  int getStatus();

  /**
   * sets the status of an entity.
   */
  void setStatus(int status);

  /**
   * gets the transient value of an entity.
   */
  double getValue();

  /**
   * Returns the initial value of an entity.
   */
  double getInitialValue();

  /**
   * Sets the initial value of an entity.
   */
  void setInitialValue(double initialValue);

  /**
   * Returns the SBML id of an entity. If none has been set, an empty string is
   *  returned.
   */
  String getSBMLId();

  /**
   * Sets the SBML id on an entity.
   * This is either done on importing an SBML file, or
   * on exporting a model. Don't mess with this since it might break further
   * exports to SBML.
   */
  void setSBMLId(String id);

  /**
   * If the entity is determined by an assignment or an ode, this
   * method will return the mathematical expression for the assignment or the
   * ODE.
   */
  String getExpression();

  /**
   * With this method, the mathematical expression for entities that
   * are determined by an assignment or an ODE can be set.
   * You might also have to set the status of the entity to indicate that it is
   * now determined by an ODE or an assignment. (see setStatus())
   */
  boolean setExpression(String expression);

  /**
   * Returns the mathematical expression for any initial assignment that might
   * have been set on the entity. This is independent of the status of the
   * entity.
   */
  String getInitialExpression();

  /**
   * With this method, the mathematical expression for the initial assignment
   * of an entity can be set.
   */
  boolean setInitialExpression(String expression);
\end{lstlisting}

The \textit{setStatus(int status)} and \textit{getStatus()} methods set and return the status of an entity respectively. The status of an entity determines how it is calculated. E.g. an entity that has a status of FIXED is not changed during a time course simulation, whereas an entity that has a status value of ASSIGNMENT is determined by an assignment expression. For a full list of valid status definitions seee table \ref{ModelEntityStatus}.

\begin{table}[ht]
\begin{tabular}{c|l}
state & description \\ \hline \hline
FIXED & entity is fixed \\ \hline
ASSIGNMENT & entity is determined by an assignment \\ \hline
REACTIONS & entity is determined by reactions (only applicable to metabolites) \\ \hline
ODE & entity is determined by an ode \\ \hline
TIME & this is the only state the model itself can have \\ \hline
\end{tabular}
\caption{model entity status}
\label{ModelEntityStatus}
\end{table}

\subsubsection{compartment}
The \textit{CCompartment} class is derived from \textit{CModelEntity} and inherits all its methods. Compartments can have the status FIXED, ASSIGNMENT or ODE. And you can set the corresponding mathematical expressions for the assignment or ODE through the methods provided by \textit{CModelEntity}. You can also either set an initial value or a mathematical expression that determines the initial value of the compartment.
In addition to the methods provided by \textit{CmodelEntity}, \textit{CCompartment} provides some methods to handle the metabolites in a compartment.

\begin{lstlisting}
/**
 * Returns a MetabVectorNS object which contains all metabolites that are
 * contained in the compartment.
 * MetabVectorNS has a size method to determine the number of metabolites and a
 * get method that takes an index and returnes the metabolite at that index.
 */
MetabVectorNS getMetabolites();

/**
 * Adds the given metabolite to the compartment.
 * If the operation succeeded, TRUE is returned, else FALSE.
 */
boolean addMetabolite(CMetab metabolite);

/**
 * Removes the given metabolite from the compartment.
 * If the operation succeeded, TRUE is returned, else FALSE.
 */
boolean removeMetabolite(CMetab metabolite);
\end{lstlisting}

\subsubsection{metabolites}
Just like the compartment class, the class for metabolites, \textit{CMetab} is derived from \textit{CModelEntity} and inherits all its methods.
Metabolites can have the status FIXED, ASSIGNMENT, ODE or REACTIONS. And you can set the corresponding mathematical expressions for the assignment or ODE through the methods provided by \textit{CModelEntity}. You can also either set an initial value or a mathematical expression that determines the initial value of the metabolite. Using the methods from \textit{CmodelEntity} to set or get values from a metabolite means that you get or set the particle number of the metabolite. If you want to work with concentrations rather than particle numbers, \textit{CMetab} provides the methods \textit{getConcentration()}, \textit{getInitialConcentration()} and \textit{setInitialConcentration(double c)} to get the concentration, initial concentration or set thr initial concentration respecitvely. The class also provides the method \textit{getCompartment()} which returns the compartment of the metabolite.

\subsubsection{model values (global parameters)}
In COPASI global parameters are called model values and the corresponding class is \textit{CModelValue} which is also derived from \textit{CModelEntity}. A global parameter can also be determined by an assignment or an ODE or it can be fixed. Global parameters can also have initial assignments.

\subsubsection{reactions}
The class for reaction is called \textit{CReaction}. It contains information on the metabolites taking part in the reaction as substrates, products or modifieres and about the kinetic law.

\begin{lstlisting}
/**
 * Returns the current flux of the reaction.
 */
double getFlux();

/**
 * Returns the current flux of the reaction in terms of particle numbers rather
 *  than concentrations
 */
double getParticleFlux();

/**
 * If the reaction is reversible, this returns TRUE, else FALSE.
 */
boolean isReversible();

/**
 * Sets whether the reaction is reversible or not.
 */
void setReversible(boolean reversible);

/**
 * Returns the number of compartments that are involved in this reaction.
 */
long getCompartmentNumber();

/**
 * Returns the SBML id of the reaction if one has been set, otherwise an empty
 * string is returned.
 */
String getSBMLId();

/**
 * Sets the SBML id of the reaction.
 * This is doen during import of an SBML model, or
 * during the first export of an SBML model.
 * If you change the SBML id of any entity, further exports to SBML
 * might fail.
 */
void setSBMLId(String id);

/**
 * Returns the chemical equation object of the reaction.
 */
CChemEq getChemEq();

/**
 * Returns the function for the kinetic law used in the reaction.
 */
CFunction getFunction();

/**
 * Sets the kinetic law of the reaction via a functions name.
 * A function with that name must exist in the function database.
 */
boolean setFunction(String functionName);
\end{lstlisting}

The \textit{getFunction} method returns the function that is used as the kinetic law. In COPASI all kinetic laws are determined by function calls. Using an expression as a kinetic law is not supported. All kinetic law expressions that are imported from SBML files are first converted to function definitions with a call to that function as the kinetic law. When those models are reexported, all expressions are exported as function calls.
There are exceptions to this rule however. If COPASI determines that a given rate law is a Mass Action rate law, no function definition is created but the Mass Action function build into COPASI is used as the kinetic law. On reexport to SBML, the kinetic law is converted to a Mass Action expression again. In the future, similar procedures might be used for other funktion types as for example constant flux.

The chemical equation of a reaction is stored in a \textit{CChemEq} object which can be aquired from the reaction with a call to \textit{getChemEq}.
The chemical equation object has several methods to query the properties of the chemical equation:

\begin{lstlisting}

/**
 * Returns TRUE if the chemical reaction is reversible.
 */
public boolean getReversibility();

/**
 * Sets whether the given chemical equation is to be reversible.
 */
public void setReversibility(boolean revers);

/**
 * Adds a new metabolite to the chemical equation.
 * key is the key of the metabolite (keys are the ids of COPASI objects)
 * mult is the stoichiometric coefficient
 * role is the role of the metabolite and it can bei either CChemEq.PRODUCT,
 * CChemEq.SUBSTRATE, CChemEq.MODIFIER or CChemEq.NOROLE.
public boolean addMetabolite(String key, double mult, int role);

/**
 * Gets a container with all the substrates of the chemical equation.
 * The size of the container can be queried with its size method,
 * the element with index i can be retrieved with the get method which takes
 * the index as the only argument.
 */
public CChemEqElementVector getSubstrates();

/**
 * Gets a container with all the products of the chemical equation.
 * The size of the container can be queried with its size method,
 * the element with index i can be retrieved with the get method which takes
 * the index as the only argument.
 */
public CChemEqElementVector getProducts();

/**
 * Gets a container with all the modifiers of the chemical equation.
 * The size of the container can be queried with its size method,
 * the element with index i can be retrieved with the get method which takes
 * the index as the only argument.
 */
public CChemEqElementVector getModifiers();

/**
 * Returns the number of compartments that are involved in this reaction.
 * If all metabolites that are involved in the reaction are in the same
 * compartment 1 is returned.
 */
public long getCompartmentNumber();

/**
 * Returns the largest compartment involved in the reaction.
 */
public CCompartment getLargestCompartment();

/**
 * Returns a CChemEqElement that represents the substrate
 * with the given index.
 */
public CChemEqElement getSubstrate(long index);

/**
 * Returns a CChemEqElement that represents the product
 * with the given index.
 */
public CChemEqElement getProduct(long index);

/**
 * Returns a CChemEqElement that represents the modifier
 * with the given index.
 */
public CChemEqElement getModifier(long index);
\end{lstlisting}

The individual entities of the chemical reaction (substrates, products and modifiers) are
represeneted by \textit{CChemEqElement} instances. A \textit{CChemEqElement} object stores the stoichiometric coefficient of the reaction entity  and the key of the associated \textit{CMetab} object. Those properties can be queried and manipulated with the following methods:

\begin{lstlisting}
/**
 * Returns the stoichiometric coefficient of the element.
 */
public double getMultiplicity();

/**
 * Sets the stoichiometric coefficient of the element.
 */
public void setMultiplicity(double multiplicity);

/**
 * Returns the associated CMetab instance.
 */
public CMetab getMetabolite();

/**
 * Returns the key of the associated CMetab instance.
 */
public String getMetaboliteKey();

/**
 * Sets the associated CMetab instance via its key.
 */
public void setMetabolite(String key);
\end{lstlisting}

\subsection{The Function Database}
The function database is the place where COPASI stores all function definitions, that is all builtin functions as well as all used defined functions. There is only one global function database and it is not associated with the current model. If the model is deleted, all functions that were used in the model stay in the function database.

The function database object is an instance of the class \textit{CFunctionDB} and the global function database can be aquired from the global instance of \textit{CCopasiDataModel}:

\begin{lstlisting}
CFunctionDB funDB=CCopasiDataModel.getGlobal().getFunctionList();
\end{lstlisting}

The \textit{CFunctionDB} class has a number of methods to get, remove or add new function defiitions.

\begin{lstlisting}
/**
 * Finds the function with the given name.
 * If no function with this name can be found, null is returned.
 */
public CEvaluationTree findFunction(String functionName);

/**
 * Returns a container with all known function definitions.
 * The size of the container can be queries with the size method and
 * individual elements of type CEvaluationTree can be aquired with the get
 * method. The only argument to the get method is the index of the desired function.
 */  
public CEvaluationTreeVectorN loadedFunctions();

/**
 * Returns a container with all functions that are suitable for the given
 * number of substrates and products and the given reversibility.
 * noSubstrates: desired number of substrates
 * noProducts: desired number of products
 * reversibility: whether the function should be suitable for reversible or
 *  irreversible reactions.
 */  
public CFunctionStdVector suitableFunctions(long noSubstrates, long noProducts, int reversibility);

/**
 * Removes the function definition with the given key.
 */
public boolean removeFunction(String key);
\end{lstlisting}

The individual function definitions are instances of the class \textit{CEvaluationTree} or of subclasses of that class, e.g. \textit{CFunction}.
COPASI distinguishes between different types of function definitions:

\begin{description}
\item[CEvaluationTree.MassAction]{this is the type of the mass action kinetic function definition}
\item[CEvaluationTree.PreDefined]{this type is set on all builtin function definitions that are not mass action}
\item[CEvaluationTree.UserDefined]{this type is set on all user defined functon definitions}
\end{description}

The type of a \textit{CEvaluationTree} object can be queried with the \textit{getType} method. 
The formula that is associated with a function definition can be queried with the \textit{getInfix} method. This method returns the equation as a ascii string. In order to set the equation one can use the \textit{setInfix} method. This method takes the formula as an ascii string and returns \textit{TRUE} if the equation has been set successfully. If there was an error, the method returns \textit{FALSE}. 

Besides the mass action function definition which is an instance if the class \textit{CMassAction} (for which there are currently no wrapper functions) all function definitions are instances of \textit{CFunction}. In addition to the method from its baseclass \textit{CEvaluationTree}, \textit{CFunction} has some additional methods to handle the function parameters and some other properties.

\begin{lstlisting}
// TODO
public int isReversible();

// TODO
public void setReversible(int reversible);

/**
 * Returns a CFunctionParameters structure that holds
 * all parameters for the function definition.
 */
public CFunctionParameters getVariables();

/**
 * Returns the index of the variable with the given name.
 * If there is no function parameter with that name, -1 is returned.
 */
public long getVariableIndex(String name);

/**
 * Returns true if the function definition is suitable for the given number
 * of substrates, products and the given reversibility.
 */
public boolean isSuitable(long noSubstrates, long noProducts, int reversible);
\end{lstlisting}

When the equation is set for a function definition, the parameters are parsed and added to the function definition.


\section{Working with Tasks}

\subsection{The Task-Problem-Method Concept in COPASI}
In COPASI calculations you can do on the current model are represented by so called tasks. The base class for all tasks is \textit{CCopasiTask}. Each task contains a problem represented by a subclass of \textit{CCopasiProblem} and a method represented by a subclass of \textit{CCopasiMethod}.
For a given task type, e.g. time course simulation, there is one task class, one problem class and one or more method classes. The problem of a task describes what is going to be done when the task is run and the method describes how it is done.
Lets make this a little more clear by looking at the task class for running time course simulations on a model. The task class for this is \textit{CTrajectoryTask} and is contains an instance of the problem class \textit{CTrajectoryProblem}. The problem for the time course simulation stores the parameters for the simulation like start time, end time and number of steps. The method class for the time course task is a subclass of \textit{CTrajectoryMethod} which itself is a subclass of \textit{CCopasiMethod}. At the time of writing, there were six method classes derived from \textit{CTrajectoryMethod}. Two of the method classes are for deterministic simulation, two are for stochastic simulation and two are for hybrid simulation. Each of the methods contains parameters that are specific to the method and which can be changed to influence the corresponding method.

All tasks are stored in \textit{CCopasiDataModel}. \textit{CCopasiDataModel} provides the method \textit{getTaskList()} to get the list of tasks. The returned object is of the type \textit{TaskVectorN} and provides a method called \textit{size()} to find out how many tasks it contains and a method \textit{get(long index)} to retieve the task with the given index. The object that is returned is of type \textit{CCopasiTask}. Alternatively, \textit{CCopasiDataModel} has a method called \textit{getTask(long index)} which also returnes the \textit{CCopasiTask} object with the given index.

To get the problem and the method for a given task, \textit{CCopasiTask} provides the methods \textit{getProblem()} and \textit{getMethod()} respectively and the objects returned are of type \textit{CCopasiProblem} and \textit{CCopasiMethod}. Normaly there is no need to cast the task, problem or method objects to the most specific subclass since the base classes already provide all the needed functionality.

All that is needed to run any task is 
\begin{itemize}
\item{get the correct task from the instance of \textit{CCopasiDataModel}}
\item{if the task does not exist yet, create a new one and add it to the instance of \textit{CCopasiDataModel}}
\item{change the parameters of the problem if the default values are not O.K.}
\item{change the method for the task if the one set is not the one that is wanted}
\item{change the parameters on the method if the default values are not O.K.}
\end{itemize}

The procedure is (almost) the same no matter what the task might be, although some tasks might need some additional steps. What those additional steps are will be explained in the corresponding sections below.   

The first thing is to get the correct task. For this the type of the task has to be known. The type of a task is an integer value and a list of all known types can be found in CCopasiTask.java. Some of those tasks are not available from Java yet. If we look at this list, we see that the type for the time course simulation task is CCopasiTask.timeCourse. So in order to find the time course task, we write a loop that checks all tasks that the CCopasiDataModel instance knows if one has the correct type. For each task type, there can be at most one task.

So to find the time course simulation task we could use the following code:

\begin{lstlisting}
long i=0;
long iMax=globalDataModel.getTaskList().size();
CTrajectoryTask task=null;
for(i=0;i<iMax;i++)
{
   if(globalDataModel.getTask(i).getType()==CCopasiTask.timeCourse)
   {
       task=globalDataModel.getTask(i);
       break;
   }
}
if(task==null)
{
   // create the task
   task=globalDataModel.addTask(new CTrajectoryTask());
}
\end{lstlisting}

The classes \textit{CCopasiProblem} and \textit{CCopasiMethod} are both derived from \textit{CCopasiParameterGroup}, they inherit all the methods from \textit{CCopasiParameterGroup} to set their parameters.
There are two ways to get a parameter, the first method retrieves a parameter by its index, the second method gets the parameter via its name.

\begin{lstlisting}
CCopasiParameter getParameter(long index);
CCopasiParameter getParameter(String name);
\end{lstlisting}

\textit{CCopasiParameterGroup}s methods \textit{size()} can be used to find out how many parameters are part of the parameter group.
Each instance of \textit{CCopasiParameter} has a type that determines what kind of values are allowed for the parameter. E.g. it determines if the parameter represents an integer a float value or a string.
Depending on the type of the parameter which can be aquired with the \textit{type()} method, the parameters value has to be set with a specific method.
Let us for example look at the parameter called "Duration" which is a parameter of CTrajectoryProblem and determines up to which time the simulation will be calculated. The parameter itself stores a double value. Assuming you already have the correct task, you can set this parameter as follows.    

\begin{lstlisting}
CTrajectoryProblem problem=(CTrajectoryProblem)task.getProblem();
CCopasiParameter parameter=problem.getParameter("Duration");
if(parameter!=null && parameter.getType()==DOUBLE)
{
    parameter.setDblValue(100.3);
}
\end{lstlisting}

This would set the parameter so that running a simulation would simulate a time length of $100.3$ time units. 

The types that are allowed for a parameter are defined in CCopasiParameter.java. The defined types as of the time of writing are those listed in \ref{ParameterTypes}

\begin{table}[ht]
\begin{tabular}{ c | c }
\hline
Type & Description \\ \hline \hline
DOUBLE &  a double value \\ \hline
UDOUBLE & a positive double value \\ \hline 
INT & an integer value (long) \\ \hline 
UINT & a positive integer value (long) \\ \hline 
BOOL & a boolean value (0 or 1) \\ \hline 
GROUP & a parameter group (parameter groups can be nested \\ \hline 
STRING & a String \\ \hline
CN & a COPASI common name (String) \\ \hline
KEY & a key (String) \\ \hline
FILE & a filename (String) \\ \hline
\end{tabular}
\label{ParameterTypes}
\caption{parameter types}
\end{table}

Most of the time you will only have to deal with the numeric parameters of type DOUBLE, INT, UINT or BOOL.

Next the method has to be set on the task. The method of a task can be set with the \textit{setMethodType(int type)} method of \textit{CCopasiTask} the argument to the method is an integer that specifies the type of the method. All methods known to COPASI hava a specific type and all those types are defined in CCopasiMethod.java. Not all methods are applicable to all tasks, normally a task has a certain set of methods that can be used with the task. If the method type passed to \textit{setMetthodType} is not applicable to the task on which the method has been called, the method return a value of \textbf{FALSE}, otherwise it returns \textbf{TRUE}.
To find out which method is currently set on a task, you can use a call to \textit{getMethodType()} which will return an integer representing the method.

Which method can be used with which task will be described in the documentation for the individual tasks.
One the correct method has been set, the method parameters can be changed which works exactly the same way as described for the parameter of the problem above, the only difference is that the methods are used in an instance of \textit{CCopasiMethod} which can be obtained from the task with a call to \textit{getMethod()}.

Once everything has been set, the task can be executed by calling the \textit{process(bool useInitialValues)} method. The boolean argument to the method determines if the task will use the current values of all model elements to run or if all values will be reset the the elements initial values. Using the current values rather than the initial values might be usefull if a simulation has already been run, but one wants to extend this simulation to get more data points.

When a task is run, the results are either stored in a report if one was defined, and/or in memory. How reports can be defined and how the results for a specific task can be obtained will be explained in the documentation for the specific tasks below.


\subsection{Running Time Course Simulations}
The procedure for running a time course simulation has more or less already been described above. 
What remains to be explained is what parameters can be used on \textit{CTrajectoryProblem} (table \ref{TrajectoryProblemParameters}) and which methods can be used with \textit{CTrajectoryTask} (table \ref{TrajectoryMethods}).

\begin{table}[ht]
\begin{tabular}{c|c|l}
Name & Type & Description \\ \hline \hline
StepNumber & UINT & number of time steps that are calculated \\ \hline
StepSize & DOUBLE & size of each time step \\ \hline
Duration & DOUBLE & length of the simulation \\ \hline
TimeSeriesRequested & BOOL & determiens if the result is to be stored in memory \\ \hline
OutputStartTime & DOUBLE & the time at which COPASI begins to produce output \\ \hline
\end{tabular}
\label{TrajectoryProblemParameters}
\caption{trajectory problem parameters}
\end{table}

\begin{table}[ht]
\begin{tabular}{c|c|l}
Type &  Description \\ \hline \hline
deterministic  & simulation with LSODA \\ \hline
LSODAR  &  simulation with LSODAR \\ \hline
stochastic &  simulation with the next reaction method \\ \hline
hybrid &  hybrid with next reaction method and runke kutta (4th order)\\ \hline
hybridLSODA & hybrid with next reaction method and LSODA \\ \hline
tauLeap & stochasitc simulation with the $\tau$-leap method \\ \hline
\end{tabular}
\label{TrajectoryMethods}
\caption{trajectory method types}
\end{table}

Here a complete example on how it could be done:

\begin{lstlisting}
long i=0;
long iMax=globalDataModel.getTaskList().size();
CTrajectoryTask task=null;
for(i=0;i<iMax;i++)
{
   if(globalDataModel.getTask(i).getType()==CCopasiTask.timeCourse)
   {
       task=globalDataModel.getTask(i);
       break;
   }
}
if(task==null)
{
   // create the task
   task=globalDataModel.addTask(new CTrajectoryTask());
}
if(task!=null)
{
  CTrajectoryProblem problem=(CTrajectoryProblem)task.getProblem();
  CCopasiParameter parameter=problem.getParameter("Duration");
  if(parameter!=null && parameter.getType()==DOUBLE)
  {
    parameter.setDblValue(100.3);
  }
  if(task.setMethodType(CCopasiMethod.LSODAR))
  {
    // maybe change some method parameters
    task.process(TRUE);
  }
  else
  {
    // error handling
  }
}
\end{lstlisting}

After running the time course simulation the results are stoed in memory if the "TimeSeriesRequested" parameter was set to \textbf{TRUE}. In order to get the results from the simulation \textit{CtrajectoryTask} provides the method \textit{getTimeSeries()} which returns an instance of \textit{CTimeSeries}.
\textit{CTimeSeries} itself provides some methods to read out the results.

\begin{lstlisting}
/**
 * Returns the number of steps in the time series. This should be the same
 * number is the "StepNumber" parameter of the CTrajectoryProblem instance plus one for
 * the initial state.
 */
long getNumSteps();

/**
 * Returns the number of variables in each row of the result.
 * Which is the same as the number of columns.
 * This inclues the column for time.
 */
long getNumVariables();

/**
 * Gets the value for a specific row and column of the result.
 * The rwos are the individual time steps and the columns are the variables.
 * Indices begin with 0 and the first column (var=0) is the time.
 * If the column represents a metabolite, this method returns the particle
 *  number.
 */
double getData(long step, long var);

/**
 * Gets the value for a specific row and column of the result.
 * The rwos are the individual time steps and the columns are the variables.
 * Indices begin with 0 and the first column (var=0) is the time.
 * If the column represents a metabolite, this method returns the concentration.
 * For all other columns, the value is the same as the one you get with
 * getData.
 */
double getConcentrationData(long step, long var);

/**
 * Get the key (id) of the element represented by the column with index var.
 */
String getKey(long var);

/**
 * Get the SBML id of the element represented by the column with index var.
 * Objects only have SBML ids if the model was imported from an SBML file, or
 * has already been exported to an SBML file.
 */
String getSBMLId(long var);
\end{lstlisting}

\subsection{Running Optimizations}
TODO

\end{document}
